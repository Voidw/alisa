chapter:Verify[Verification Plans for a System]

The e[Verify] notation lets users specify verification plans for each system component in a system architecture.

A verification plan specifies how the claim that every requirement of a system component is satisfied by a system implementation. 
This is achieved by specifying a set of verification activities that must complete successfully as evidence for the claim.  

A verification activity is performed on an artifact representing the system implementation. 
This artifact may be an AADL model representing the architecture specification of the system, detailed design models, e.g., Simulink models of physical or control behavior, or the actual implementation, e.g., in form of software that must be executed on a hardware platform.
Verification activities may also include review of documents, design, or code by human reviewers.

A verification activity identifies the verification method to be used, the artifact the method is applied to, any additional input to be used when performing the verification activity, and expected results. Note that expected results may already have been specified as part of  the requirement specification.
However, some verification activities may expect results in particular formats that were not prescribed by the requirement specification. Verification activities are specified in libraries and may be used in multiple verification plans.

A verification method registry allows users to specify the type and signature of a verification method. The actual method may take a variety of forms. However, the methods have a common interface to interface with the Alisa incremental assurance engine. 

section:VerificationPlans[Verification Plans]


A verification plan is defined in a separate file with the extension e[verify].


code[Verify][
<VerificationPlan> ::=
	plan myplan ( : "descriptive title" )?
	for MyPackage::GPSSystem
	\[
		( description "Verification plan for a second line" )? 
		<Claim>*
		( rationale <String> )?
		( assume <VerificationPlan>+ )?
	    ( issues ("explanation")+ )? 
	\]
]

A verification plan is for a single system identified by the reference to its AADL classifier.

The verification plan specifies a claim for each of the requirements that have been specified for a system.

A system can have multiple verification plans that get combined into an assurance plan.

e[assume verified] identifies subsytems (system components) that are assumed to have been verified
separately. This allows us to support compositional assurance of systems.

code[Verify][
<Claim> ::=
	claim claimID ( : "Descriptive title" )?
	( '(' <claimweight> ')' )?
	for <requirement reference>
	\[
		( assert <ArgumentExpression>
		( argument <String> <Uncertainty> )?
	 	( rationale <String> )?
		( <Claim> )*  
	    ( issues ("explanation")+ )? 
	\]
]

A requirement for a system may have been refined into sub-requirements that are verifiable. Typically,
only the leaf elements of a requirement refinement hierarchy involve veritication activities. Howeever,
the notation supports the possibility for a veritication activity for each requirement in the refinement
hierarchy.

Weights are used to specify the value of evidence contribution a particular claim or
verification activity has.

code[Verify][
<ArgumentExpr> ::=
		all \[ <ArgumentExpr>+ \] |
		<ArgumentExpr> failthen <ArgumentExpr> |
		<ArgumentExpr> unknownthen <ArgumentExpr> |
		<ArgumentExpr> andthen <ArgumentExpr> |
		<ConditionalEvidence> 
		( <ArgumentExpr> )
		
ConditionalEvidence ::=
	verificationActivity1 ( '(' 0.8 ')' )? ( when <sectioncategoryreference>+ )?
]

e[all] means that all verification activities will be executed independent of whether they are successful
or fail. The result state of the e[all] operator is then evaluated ans is only sucvcessful if all listed
verification activities.

e[unknownthen] means that the second test is only executed as an alternative if the first verification activity produces an unknown result,,
i.e., has a timeout or otherwise fails to complete executing the verificaiton method.
In other words, users can specify alternate verification activities if the original ones fail.

e[failthen] means that the second test is only executed as an alternative if the first verification activity fails.
In other words, users can specify alternate verification activities if the original ones fail.

e[andthen] lets users specify an ordering of verification activities, i.e., the second verification activity
is only executed if the first one is successful.

e[Brackets] allow users to specify a change in precedence ordering of argument expression operators.

Argument expressions refer to verification activities defined in libraries. 

These references will be executed conditionally according to whether the specified selection categories are specified in the selection criteria of an assurance plan. 

Each verification activity can have a weight to express the value of the contributed evidence. 


section:VerificationActivities[Verification Activities]


A library of verification activities is defined in a separate file with the extension e[verify].


code[Verify][
<VerificationLibrary> ::=
	library libraryname ( :  "descriptive title" )?
	( for mypackage::myGPS )?
	\[
		( description Description)?
		( <VerificationActivity> |  <VerificationFolder> )*
	\]

<VerificationFolder> ::=
	folder foldername
	\[ 
		( <VerificationActivity> |  <VerificationFolder> )*
	\];


<VerificationActivity> ::=
	activity activityname ( : "descriptive title" )?
	( for <requirementreference> )?
	\[ 
		( description Description )?
		method <VerificationMethodReference> ( as <ComputeVariable Reference> )?
		( timeout  <integer> )?
		( rationale "explanation" )?
	\]
]

section:VerificationMethods[Registry of Verification Methods]

A verification method registry is defined in a separate file with the extension e[verify].

code[Verify][
<VerificationMethodRegistry> ::=
	registry registryname
	( : "descriptive title" )?
	\[ 
		( description Description )?
		<VerificationMethod>+
	\]

<VerificationMethod> ::=
	method methodname ( :  "descriptive title" )?
	( for <requirementreference> )?	
	\[
		<MethodType>  <MethodScope> ( <MethodReporting> )?
		path "my.pack.myclass.mymethod"
		( description Description )?
		( category <VerificationCategory> )?
		( VerificationValidation | VerificationPrecondition)*
	\]

VerificationValidation ::=
	( validation myname
	( : "title" )?
	\[ (
	( description Description)?
	  method <methodid> ( as <computer variable> )?
	( rationale "rationale description" )?
	)
	\]


VerificationPrecondition ::=
	( precondition myname
	( : "title" )?
	\[ 
	( description Description)?
	  method <methodid> ( as <computer variable> )?
	( rationale "rationale description" )?
	\]


enum MethodTypes::= analysis | predicate | compute | resoluteprove | manual
	
enum MethodScope::= self | parts | all 

enum MethodReporting::= marker| errormarker | diagnostics | assertexception | resultreport
]

The method types are:
ul[
item[e[predicate:] the method evaluates one instance model element and returns true (success) or false (fail) according to a built-in predicate. The predicate may interpret a property in the model as the limit value of the predicate.
Fail can be reported by an e[AssertionException]. Failure to complete verification method execution,
e.g., timeout or an exception other than e[AssertionException] is mapped into e[unknown].
]
item[e[analysis:] the method represents procesisng by an OSATE analysis plug-in. Typically it processes
multiple model elements and reports results via markers.]
item[e[compute:] the method processes one model element and returns a single value as a result. This
value is then evaluated by the specified predicate of the requirement.]
item[e[resoluteprove:] the method interpretively evaluates a Resolute claim function as if it where declared
in a e[prove] statement in a e[resolute subclause]. This allows resolute claim functions to be associated
with AADL models without embedding them in the model.
]
item[e[manual:] the method represents a manual method, i.e., a method that is performed by a human. The
person will interactively report the result of the verification, e.g., the result of performing a review.]
]

The following are scopes of application that can be defined for verificaiton methods:
ul[
item[e[self:] the method applies to the model element identified by the requirement.]
item[e[parts:] the method applies to all parts of a component that is identified by the requirement.
The parts are all directly contained elements without recursively traversing the component hierarchy.
For example, the method may evaluate all ports or all end to end flows defined in a component.]
item[e[all:] the method applies to all elements of the component identified by the requirement - recursively
traversing the hierarchy. ]
]

The following are reporting mechanisms that may be used by a veriifcation method. If not specified, th
e use of Eclispe markers is assumed.
ul[
item[e[marker:] Eclipse e[markers] of types e[error], e[warning], and e[info] may be used to report back
results of teh verification method.]
item[e[errormarker:] Eclipse e[markers] of type e[error] are used to report back issues in the exectuion
of the veriifcation method.]
item[e[diagnostics:] The Eclipse e[Diagnostics] mechanism is used to rept back results.]
item[e[assertexception:] An e[AssertionException] is thrown by the veriifcation method to report back
a failed test or failure to compelte execution. ]
item[e[resultreport:] A result report format defined by e[Alisa] is used to report back results.]
]

section:BuiltinRegistry[Built-in and User-defined Registries]

Alisa comes with a built-in registry of verification methods. The registry is ucrrently omly partially
populated. The registry include several verification methods that interface with OSATE analysis plug-ins,
methods written in Xtend specifically for use in Alisa, and methods written in Resolute. See the method
registry in the e[Alisa  Test Case] on teh SVN repository.

Users can add currently verificaiton methods to Alisa in two ways. First, users can write claim functions
and computational methods in Resolute (see Resolute language specificaiton for details). Uses then define
their own verification method registry to complement the "predefined" registry. SInce Resolute is an
interpreted notation, these newly registered methods are immediately available for use.

Users can also write or make use of verification methods written in compiled languages, such as Java
or Xtend. In some cases, users may write wrapper methods to interface existing tools or external tools, such as
e[JUnit] or e[Simulink]. This currently requires users to write a e[dispatcher] that handles newly introduced
verification methods by overridind the dispatcher for the builtin methods. See the builtin e[AnalysisPluginDispatcher]
in e[org.osate.assure.analysis] for a pattern. You want to put this code in a new Eclipse plug-in. You
can test the code by invoking Eclispe recursively from OSATE as if it is a development environment. Once
tested you can add the plug-in into the dropins folder of your OSATE/Alisa installation.

In the future we will make use of relfective invocation to allow for more interactive development of
verificaiotn methods. We wil also integrate frameworks such as JUnit into Alisa via teh verificaiton
method registry.

section:SelectionCategories[Selective Verification]

Selective verification is patterned after JUnit. Users can attach multiple category labels with a referenced
verification activity. Separately, user will specifiy the categories of interest when defining and instanitating
an assurance plan.

The selection categories can be defined by the user. They are defined the same

Requirement categories are defined through the Category specificaiton notation. These specifications are
created in files with the extension @e[cat].

code[Categories][
<SelectionCategories> ::=
	selection categories 
	\[ 
		<SelectionCategory>+
	\]

<SelectionCategory> :
	phase1 ( extends phase )? 
]

Selection categories must have globally unique names among selection category declarations within an Eclipse workspace. 
References to a category do not have to be qualified.

Requirement categories can be placed into an extends hierarchy.

