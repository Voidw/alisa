<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>Verification Plans for a System</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.1.2  (Win32)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Peter Feiler">
	<META NAME="CHANGED" CONTENT="20151118;11463450">
	<STYLE TYPE="text/css">
	<!--
		P { margin-top: 0.1in; margin-bottom: 0.1in; color: #000000; font-family: "Arial", "Helvetica", sans-serif; font-size: 10pt }
		H1 { color: #000000; font-family: "Arial", "Helvetica", sans-serif; font-size: 18pt }
		H2 { color: #000000; font-family: "Arial", "Helvetica", sans-serif; font-size: 14pt }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" TEXT="#000000" DIR="LTR">
<H1><A NAME="Verify"></A>Verification Plans for a System</H1>
<P>The <EM>Verify</EM> notation lets users specify verification plans
for each system component in a system architecture. 
</P>
<P>A verification plan specifies how every requirement of a system
component (type or implementation) is verified, i.e., a system
implementation meets the requirements. This is achieved by specifying
a set of verification activities that must complete successfully as
evidence that a requirement is met. This is done by a claim
declaration for each requirement in the verification plan. 
</P>
<P>A verification activity is performed on an artifact representing
the system implementation. This artifact may be an AADL model
representing the architecture specification of the system, detailed
design models, e.g., Simulink models of physical or control behavior,
or the actual implementation, e.g., in form of software that must be
executed on a hardware platform. Verification activities may also
include review of documents, design, or code by human reviewers. 
</P>
<P>A verification activity identifies the verification method to be
used, and a set of parameters. By default every verification method
is assumed to accept a reference to a model element, typically an
AADL instance model element. The verification method may accept
additional parameters,  or it may expect the relevant information to
be available as a property on the AADL model. By default the
verification method is expected to return a Boolean as result.
Verification methods may also return results via Eclipse Markers, in
Resolute result format, or in a result report format defined by
Alisa.</P>
<P>A verification method registry allows users to specify the type
and signature of a verification method. The actual method may take a
variety of forms. However, the methods have a common interface to
interface with the Alisa incremental assurance engine. Currently we
support Osate analysis plug-ins, Resolute, and Java/Xtend based
method implementations.</P>
<P>The <I>Verify </I><SPAN STYLE="font-style: normal">notation
supports two file extensions: </SPAN><I>verify</I><SPAN STYLE="font-style: normal">
for verification plans, and </SPAN><I>methodregistry</I><SPAN STYLE="font-style: normal">
for verification method specifications.</SPAN></P>
<H2><A NAME="VerificationPlans"></A>Verification Plans</H2>
<P>Verification plans are defined in files with the extension <EM>verify</EM>.
Multiple verification plans can be placed in a single file. It is
recommended that one verification plan is declared for each set of
<I>system requirements</I><SPAN STYLE="font-style: normal">. Users
may want to follow the convention to name the set of </SPAN><I>system
requirements</I><SPAN STYLE="font-style: normal"> by a
&lt;dot.-separated qualified name path corresponding to the
component, whose requirements are specified &ndash; and the same name
be used for the verification plan.</SPAN></P>
<P>&lt;VerificationPlan&gt; ::= <BR><FONT COLOR="#7f0055"><B>verification
plan</B></FONT> (qual <FONT COLOR="#7f0055"><B>.</B></FONT> )*
name<BR> ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;descriptive title&quot;</SPAN></FONT> )?
<BR>    <FONT COLOR="#7f0055"><B>for</B></FONT> &lt;system
requirements reference&gt;
<BR>    <FONT COLOR="#7f0055"><B>[</B></FONT><BR>        ( <FONT COLOR="#7f0055"><B>description</B></FONT> <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;Verification plan for a second line&quot;</SPAN></FONT> )? <BR>
        &lt;Claim&gt;*
<BR>        ( <FONT COLOR="#7f0055"><B>rationale</B></FONT> &lt;String&gt; )?
<BR>       ( <FONT COLOR="#7f0055"><B>issues</B></FONT> (<FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;explanation&quot;</SPAN></FONT>)+ )? 
<BR>    <FONT COLOR="#7f0055"><B>]</B></FONT></P>
<P>A verification plan is for a set of requirement specifications
identified by the <I>for </I><SPAN STYLE="font-style: normal">statement.
The set of requirement specifications is for an</SPAN> AADL component
type or implementation identified in the <I>requirement specification
</I><SPAN STYLE="font-style: normal">declaration. A component type
extension may have its own requirement specification separate from
the component type being extended</SPAN>. Similarly, a separate
verification plan is defined. When we instantiate an assurance plan
the verification plans of a component classifier and the classifiers
being extended are included. For implementations the plans of the
respective type are included.</P>
<P>The verification plan specifies a claim for each of the
requirements that have been specified for a system. 
</P>
<P>A system can have multiple verification plans that get combined
into an assurance plan. 
</P>
<P><EM>assume verified</EM> identifies subsystems (system components)
that are assumed to have been verified separately. This allows us to
support compositional assurance of systems. 
</P>
<P>&lt;Claim&gt; ::= <BR>    <FONT COLOR="#7f0055"><B>claim</B></FONT> &lt;requirement
ID reference&gt;<BR>   ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;Descriptive title&quot;</SPAN></FONT> )?
<BR>    ( <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&amp;apos;(&amp;apos;</SPAN></FONT> &lt;claimweight&gt; <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&amp;apos;)&amp;apos;</SPAN></FONT> )?<BR>
    <FONT COLOR="#7f0055"><B>for</B></FONT> &lt;requirement reference&gt;<BR>
    [<BR>         ( <FONT COLOR="#7f0055"><B>assert</B></FONT> &lt;ArgumentExpression&gt;
<BR>         ( <FONT COLOR="#7f0055"><B>argument</B></FONT> &lt;String&gt; &lt;Uncertainty&gt; )?<BR>
         ( <FONT COLOR="#7f0055"><B>rationale</B></FONT> &lt;String&gt; )?<BR>
        ( &lt;Claim&gt; )*<BR>
        ( <FONT COLOR="#7f0055"><B>issues</B></FONT> (<FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;explanation&quot;</SPAN></FONT>)+ )?<BR>
    ] 
</P>
<P>A requirement for a system may have been refined into
sub-requirements that are verifiable. Typically, only the leaf
elements of a requirement refinement hierarchy involve veritication
activities. Howeever, the notation supports the possibility for a
veritication activity for each requirement in the refinement
hierarchy. 
</P>
<P>Weights are used to specify the value of evidence contribution a
particular claim or verification activity has. 
</P>
<P>&lt;ArgumentExpr&gt; ::=         <FONT COLOR="#7f0055"><B>all</B></FONT> [ &lt;ArgumentExpr&gt;+ ] |
        &lt;ArgumentExpr&gt; <FONT COLOR="#7f0055"><B>failthen</B></FONT> &lt;ArgumentExpr&gt; |
        &lt;ArgumentExpr&gt; <FONT COLOR="#7f0055"><B>unknownthen</B></FONT> &lt;ArgumentExpr&gt; |
        &lt;ArgumentExpr&gt; <FONT COLOR="#7f0055"><B>andthen</B></FONT> &lt;ArgumentExpr&gt; |
        &lt;ConditionalEvidence&gt; 
        ( &lt;ArgumentExpr&gt; )
        
ConditionalEvidence ::=
    verificationActivity1 ( <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&amp;apos;(&amp;apos;</SPAN></FONT> 0.8 <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&amp;apos;)&amp;apos;</SPAN></FONT> )? ( <FONT COLOR="#7f0055"><B>when</B></FONT> &lt;sectioncategoryreference&gt;+ )?
</P>
<P><EM>all</EM> means that all verification activities will be
executed independent of whether they are successful or fail. The
result state of the <EM>all</EM> operator is then evaluated ans is
only sucvcessful if all listed verification activities. 
</P>
<P><EM>unknownthen</EM> means that the second test is only executed
as an alternative if the first verification activity produces an
unknown result,, i.e., has a timeout or otherwise fails to complete
executing the verificaiton method. In other words, users can specify
alternate verification activities if the original ones fail. 
</P>
<P><EM>failthen</EM> means that the second test is only executed as
an alternative if the first verification activity fails. In other
words, users can specify alternate verification activities if the
original ones fail. 
</P>
<P><EM>andthen</EM> lets users specify an ordering of verification
activities, i.e., the second verification activity is only executed
if the first one is successful. 
</P>
<P><EM>round brackets</EM> allow users to specify a change in
precedence ordering of argument expression operators. 
</P>
<P>Argument expressions refer to verification activities defined in
libraries. 
</P>
<P>These references will be executed conditionally according to
whether the specified selection categories are specified in the
selection criteria of an assurance plan. 
</P>
<P>Each verification activity can have a weight to express the value
of the contributed evidence. 
</P>
<H2><A NAME="VerificationActivities"></A>Verification Activities</H2>
<P>A library of verification activities is defined in a separate file
with the extension <EM>verify</EM>. 
</P>
<P>&lt;VerificationLibrary&gt; ::=
    <FONT COLOR="#7f0055"><B>library</B></FONT> libraryname ( :  <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;descriptive title&quot;</SPAN></FONT> )?
    ( <FONT COLOR="#7f0055"><B>for</B></FONT> mypackage::myGPS )?
    [         ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description)?
        ( &lt;VerificationActivity&gt; |  &lt;VerificationFolder&gt; )*
    ] &lt;VerificationFolder&gt; ::=
    <FONT COLOR="#7f0055"><B>folder</B></FONT> foldername
    [ 
        ( &lt;VerificationActivity&gt; |  &lt;VerificationFolder&gt; )*
    ]; &lt;VerificationActivity&gt; ::=
    <FONT COLOR="#7f0055"><B>activity</B></FONT> activityname ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;descriptive title&quot;</SPAN></FONT> )?
    ( <FONT COLOR="#7f0055"><B>for</B></FONT> &lt;requirementreference&gt; )?
    [          ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description )?
        <FONT COLOR="#7f0055"><B>method</B></FONT> &lt;VerificationMethodReference&gt; ( <FONT COLOR="#7f0055"><B>as</B></FONT> &lt;ComputeVariable Reference&gt; )?
        ( <FONT COLOR="#7f0055"><B>timeout</B></FONT>  &lt;integer&gt; )?
        ( <FONT COLOR="#7f0055"><B>rationale</B></FONT> <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;explanation&quot;</SPAN></FONT> )?
    ] 
</P>
<H2><A NAME="VerificationMethods"></A>Registry of Verification
Methods</H2>
<P>A verification method registry is defined in a separate file with
the extension <EM>verify</EM>. 
</P>
<P>&lt;VerificationMethodRegistry&gt; ::=
    <FONT COLOR="#7f0055"><B>registry</B></FONT> registryname
    ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;descriptive title&quot;</SPAN></FONT> )?
    [          ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description )?
        &lt;VerificationMethod&gt;+
    ] &lt;VerificationMethod&gt; ::=
    <FONT COLOR="#7f0055"><B>method</B></FONT> methodname ( :  <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;descriptive title&quot;</SPAN></FONT> )?
    ( <FONT COLOR="#7f0055"><B>for</B></FONT> &lt;requirementreference&gt; )?    
    [
        &lt;MethodType&gt;  &lt;MethodScope&gt; ( &lt;MethodReporting&gt; )?
        <FONT COLOR="#7f0055"><B>path</B></FONT> <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;my.pack.myclass.mymethod&quot;</SPAN></FONT>
        ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description )?
        ( <FONT COLOR="#7f0055"><B>category</B></FONT> &lt;VerificationCategory&gt; )?
        ( VerificationValidation | VerificationPrecondition)*
    ] VerificationValidation ::=
    ( <FONT COLOR="#7f0055"><B>validation</B></FONT> myname
    ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;title&quot;</SPAN></FONT> )?
    [ (     ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description)?
      <FONT COLOR="#7f0055"><B>method</B></FONT> &lt;qualified methodname&gt; ( <FONT COLOR="#7f0055"><B>as</B></FONT> &lt;computer variable&gt; )?
    ( <FONT COLOR="#7f0055"><B>rationale</B></FONT> <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;rationale description&quot;</SPAN></FONT> )?
    )     ]
VerificationPrecondition ::=     ( <FONT COLOR="#7f0055"><B>precondition</B></FONT> myname
    ( : <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;title&quot;</SPAN></FONT> )?
    [      ( <FONT COLOR="#7f0055"><B>description</B></FONT> Description)?
      <FONT COLOR="#7f0055"><B>method</B></FONT> &lt;qualified methodname&gt; ( <FONT COLOR="#7f0055"><B>as</B></FONT> &lt;computer variable&gt; )?
    ( <FONT COLOR="#7f0055"><B>rationale</B></FONT> <FONT COLOR="#2a00ff"><SPAN STYLE="font-weight: normal">&quot;rationale description&quot;</SPAN></FONT> )?
    ]
<FONT COLOR="#7f0055"><B>enum</B></FONT> MethodTypes::= analysis | predicate | compute | 
        resoluteprove | resolutecompute | resolutepredicate | manual
     <FONT COLOR="#7f0055"><B>enum</B></FONT> MethodScope::= self | parts | <FONT COLOR="#7f0055"><B>all</B></FONT> 
<FONT COLOR="#7f0055"><B>enum</B></FONT> MethodReporting::= marker| errormarker | diagnostics | assertexception | resultreport
</P>
<P>The method types are: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in"><EM>analysis:</EM> the method
	represents processing by an OSATE analysis plug-in. Typically it
	processes multiple model elements and reports results via markers. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>predicate:</EM> the method
	evaluates a condition on one instance model element and returns true
	(success) or false (fail). Fail may be reported by a Jave/JUnit
	<EM>AssertionException</EM> - see reporting mechanism. Failure to
	complete verification method execution, e.g., timeout or an
	exception other than <EM>AssertionException</EM> is mapped into
	<EM>unknown</EM>. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>compute:</EM> the method
	processes one model element and returns a single value as a result.
	This value is then evaluated by the specified predicate of the
	requirement. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>resoluteprove:</EM> the method
	interpretively evaluates a Resolute claim function as if it where
	declared in a <EM>prove</EM> statement in a <EM>resolute subclause</EM>.
	This allows resolute claim functions to be associated with AADL
	models without embedding them in the model. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>resolutepredicate:</EM> the
	method interpretively evaluates a Resolute computational function
	with a boolean result. The predicate is assumed to represent the
	condition to be asserted for a requirement. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>resolutecompute:</EM> the
	method interpretively evaluates a Resolute computational function.
	The result value is then evaluated by the specified of the
	requirement. 
	</P>
	<LI><P><EM>manual:</EM> the method represents a manual method, i.e.,
	a method that is performed by a human. The person will interactively
	report the result of the verification, e.g., the result of
	performing a review. 
	</P>
</UL>
<P>The following are scopes of application that can be defined for
verification methods: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in"><EM>self:</EM> the method applies
	to the model element identified by the requirement. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>parts:</EM> the method applies
	to all parts of a component that is identified by the requirement.
	The parts are all directly contained elements without recursively
	traversing the component hierarchy. For example, the method may
	evaluate all ports or all end to end flows defined in a component. 
	</P>
	<LI><P><EM>all:</EM> the method applies to all elements of the
	component identified by the requirement - recursively traversing the
	hierarchy. 
	</P>
</UL>
<P>The following are reporting mechanisms that may be used by a
veriifcation method. If not specified, th e use of Eclispe markers is
assumed. 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in"><EM>marker:</EM> Eclipse <EM>markers</EM>
	of types <EM>error</EM>, <EM>warning</EM>, and <EM>info</EM> may be
	used to report back results of teh verification method. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>errormarker:</EM> Eclipse
	<EM>markers</EM> of type <EM>error</EM> are used to report back
	issues in the exectuion of the veriifcation method. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>diagnostics:</EM> The Eclipse
	<EM>Diagnostics</EM> mechanism is used to rept back results. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><EM>assertexception:</EM> An
	<EM>AssertionException</EM> is thrown by the veriifcation method to
	report back a failed test or failure to compelte execution. 
	</P>
	<LI><P><EM>resultreport:</EM> A result report format defined by
	<EM>Alisa</EM> is used to report back results. 
	</P>
</UL>
<H2><A NAME="BuiltinRegistry"></A>Built-in and User-defined
Registries</H2>
<P>Alisa comes with a built-in registry of verification methods. The
registry is ucrrently omly partially populated. The registry include
several verification methods that interface with OSATE analysis
plug-ins, methods written in Xtend specifically for use in Alisa, and
methods written in Resolute. See the method registry in the <EM>Alisa
Test Case</EM> on teh SVN repository. 
</P>
<P>Users can add currently verificaiton methods to Alisa in two ways.
First, users can write claim functions and computational methods in
Resolute (see Resolute language specificaiton for details). Uses then
define their own verification method registry to complement the
&quot;predefined&quot; registry. SInce Resolute is an interpreted
notation, these newly registered methods are immediately available
for use. 
</P>
<P>Users can also write or make use of verification methods written
in compiled languages, such as Java or Xtend. In some cases, users
may write wrapper methods to interface existing tools or external
tools, such as <EM>JUnit</EM> or <EM>Simulink</EM>. This currently
requires users to write a <EM>dispatcher</EM> that handles newly
introduced verification methods by overridind the dispatcher for the
builtin methods. See the builtin <EM>AnalysisPluginDispatcher</EM> in
<EM>org.osate.assure.analysis</EM> for a pattern. You want to put
this code in a new Eclipse plug-in. You can test the code by invoking
Eclispe recursively from OSATE as if it is a development environment.
Once tested you can add the plug-in into the dropins folder of your
OSATE/Alisa installation. 
</P>
<P>In the future we will make use of relfective invocation to allow
for more interactive development of verificaiotn methods. We wil also
integrate frameworks such as JUnit into Alisa via teh verificaiton
method registry. 
</P>
<H2><A NAME="SelectionCategories"></A>Selective Verification</H2>
<P>Selective verification is patterned after JUnit. Users can attach
multiple category labels with a referenced verification activity.
Separately, user will specifiy the categories of interest when
defining and instanitating an assurance plan. 
</P>
<P>The selection categories can be defined by the user. They are
defined the same 
</P>
<P>Requirement categories are defined through the Category
specificaiton notation. These specifications are created in files
with the extension @<EM>cat</EM>. 
</P>
<P>&lt;SelectionCategories&gt; ::=     <FONT COLOR="#7f0055"><B>selection</B></FONT> <FONT COLOR="#7f0055"><B>categories</B></FONT> 
    [          &lt;SelectionCategory&gt;+
    ] &lt;SelectionCategory&gt; :
    phase1 ( <FONT COLOR="#7f0055"><B>extends</B></FONT> phase )? 
</P>
<P>Selection categories must have globally unique names among
selection category declarations within an Eclipse workspace.
References to a category do not have to be qualified. 
</P>
<P>Requirement categories can be placed into an extends hierarchy. 
</P>
</BODY>
</HTML>