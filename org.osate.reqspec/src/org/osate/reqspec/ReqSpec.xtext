grammar org.osate.reqspec.ReqSpec with org.osate.alisa.common.Common

generate reqSpec "http://www.osate.org/reqspec/ReqSpec"

import "http://aadl.info/AADL/2.0" as aadl2
import  "http://www.osate.org/categories/Categories" as categories
import  "http://www.osate.org/organization/Organization" as org
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

//ReqSpec: contents +=(ReqSpecs|StakeholderGoals|ReqDocument)  ;
ReqSpec: ReqSpecs|StakeholderGoals|ReqDocument  ;

ReqSpecContainer: ReqSpecs  | ReqSpecFolder  |GoalFolder | StakeholderGoals | ReqDocument;

ContractualElement: Goal | Requirement ;

ReqRoot:  StakeholderGoals | ReqDocument | ReqSpecs;


StakeholderGoals: 'stakeholder' 'goals' name=ID (':' title=STRING)?
	( 'for' (target=[aadl2::Classifier|AadlClassifierReference]| targetDescription=STRING))?
	 ('description'  description=Description)? 
	'[' content+=( Goal | GoalFolder) ']'
;

ReqDocument: 'document' name=ID (':' title=STRING)?
	 ('description'  description=Description)? 
	'[' content+=DocumentSection ']'
;
DocumentSection returns DocumentSection:
	'section' label =ID (':' title=STRING)?
	 ('description'  description=Description)? 
	'[' (content+= (Goal | Requirement |  DocumentSection))*
	']'
	;

ReqSpecs returns ReqSpecs:
	'requirement' 'specification' name =ID (':' title=STRING)?
//	('import' importedNamespace=QualifiedNameWithWildCard)?
	( 'for' target=[aadl2::Classifier|AadlClassifierReference])?
	('include' otherreqspecs += [ReqSpecs|QualifiedName]+)?
	'[' 
	(
		'constants'
	constants+=XValDeclaration* 
	& (content+= (Requirement |  ReqSpecFolder))*
	)
	']'
	;

// does not add to a qualified name
ReqSpecFolder returns ReqSpecFolder:
	'folder' label =ID (':' title=STRING)?
	'[' (content+= (Goal | Requirement |  ReqSpecFolder))*
	']'
	;

// does not add to a qualified name
GoalFolder returns GoalFolder:
	'folder' label =ID (':' title=STRING)?
	'[' (content+= (Goal |  GoalFolder))*
	']'
	;

	

Goal returns Goal:
	'goal' name=ID (':'  title=STRING )? // short string for title
	( 'for' (target=[aadl2::NamedElement|ID] | targetDescription=STRING) 
//		('of' targetContext=[aadl2::Classifier|AadlClassifierReference])?
	)?
'['  (
	 ('category'  category=[categories::RequirementCategory|ID])?
	 &('description'  description=Description)? 
	 &('rationale'  rationale=STRING)? 
	 &('refines' refinesReference+=[Goal|QualifiedName]+)? 
	 &('conflicts' 'with' conflictsReference+=[Goal|QualifiedName]+)? 
	 &('stakeholder'  stakeholderReference+=[org::Stakeholder|QualifiedName]+)?
	 &('see' 'document''requirement'  documentRequirement+=[ContractualElement|QualifiedName]+)?
	 &('see' 'document'  docReference+=ExternalDocument+)? 
	)
	 ']';


// requirement without target acts as a general requirement/constraint
// becomes a "global" constraint that still takes model elements that are supplied by query 	
Requirement:
	'requirement'  name=ID   
	(':'  title=STRING)? 
	( 'for' (target=[aadl2::NamedElement|ID] | targetDescription=STRING)
//		('of' targetContext=[aadl2::Classifier|AadlClassifierReference])?
	)?
'['	(
 	('category'  category=[categories::RequirementCategory|ID] )?
	&('description'  description=Description)? 
	& ( 'constants' constants+=XValDeclaration+ )?
	&('assert'  predicate=ReqPredicate)?  // predicate expression 
	&('rationale'  rationale=STRING)? 
	&('see' 'goal'  goalReference+=[Goal|QualifiedName]+)?
	&('mitigates'  (exception=[ecore::EObject|ID]|exceptionText=STRING))? 
	&('refines' refinedReference+=[Requirement|QualifiedName]+)? 
	&('see' 'document' 'goal'  stakeholderRequirementReference+=[Goal|QualifiedName]+)?
	 &('see' 'document' 'requirement'  documentRequirement+=[ContractualElement|QualifiedName]+)?
	 &('see' 'document'  docReference+=ExternalDocument+)? 
	)
	']';

ReqPredicate: InformalPredicate | XPredicate | SPeARPredicate;

InformalPredicate: description=STRING ;

XPredicate: Xlambda=XClosure;	

SPeARPredicate: 'inv' predicate=STRING ;

ExternalDocument : 
	docReference=DOCPATH ( '#' docFragment=DOCFRAGMENT)?
;


// path to external document and its fragment
DOCPATH: ( ID '/')* ID '.' ID;

DOCFRAGMENT: ID ('.' ID)*;

	