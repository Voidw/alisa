grammar org.osate.reqspec.ReqSpec with org.osate.alisa.common.Common

generate reqSpec "http://www.osate.org/reqspec/ReqSpec"

import "http://aadl.info/AADL/2.0" as aadl2
import  "http://www.osate.org/categories/Categories" as categories
import  "http://www.osate.org/organization/Organization" as org

ReqSpec: contents +=(ReqSpecLibrary|SystemSpec|StakeholderGoals|ReqDocument)  ;

ReqSpecContainer: ReqSpecLibrary  | ReqSpecFolder  ;

ContractualElement: Goal | Requirement | Hazard;

ReqRoot: SystemSpec | StakeholderGoals | ReqDocument;

SystemSpec: 'specification' name=ID
	'for' target=[aadl2::Classifier|AadlClassifierReference]
	'[' consistsOf+=[ReqSpecLibrary|QualifiedName] ']'
;


StakeholderGoals: 'goals' name=ID
	'[' consistsOf+=[ReqSpecLibrary|QualifiedName] ']'
;

ReqDocument: 'document' name=ID
	'[' consistsOf+=[ReqSpecLibrary|QualifiedName] ']'
;

ReqSpecLibrary returns ReqSpecLibrary:
	'library' name =ID 
	('import' importedNamespace=QualifiedNameWithWildCard)?
	( 'for' target=[aadl2::Classifier|AadlClassifierReference])?
	'[' 
	('constants' constants+=FinalValue+)?
	(content+= (Goal | Requirement | Hazard |  ReqSpecFolder))*
	']'
	;
QualifiedNameWithWildCard : QualifiedName ('.*')?;	

// does not add to a qualified name
ReqSpecFolder returns ReqSpecFolder:
	'folder' label =ID 
	'[' (content+= (Goal | Requirement | Hazard |  ReqSpecFolder))*
	']'
	;

	

Goal returns Goal:
	'goal' name=ID (':'  title=ValueString )? // short string for title
	( 'for' target=[aadl2::NamedElement|ID] 
//		('of' targetContext=[aadl2::Classifier|AadlClassifierReference])?
	)?
'['  (
	 ('category'  category=[categories::RequirementCategory|CatRef])?
	 &('description'  description=Description)? 
	 &('assert'  	assert=PredicateExpression )? 
	 &('rationale'  rationale=STRING)? 
	 &('refined' 'to' refinesReference+=[Goal|QualifiedName](',' refinesReference+=[Goal|QualifiedName])*)? 
	 &( subgoal+=Goal*) 
	 &('decomposed' 'to' decomposesReference+=[Goal|QualifiedName](',' decomposesReference+=[Goal|QualifiedName])*)? 
	 &('evolved' 'to' evolvesReference+=[Goal|QualifiedName](',' evolvesReference+=[Goal|QualifiedName])*)? 
	 &('conflicts' 'with' conflictsReference+=[Goal|QualifiedName](',' conflictsReference+=[Goal|QualifiedName])*)? 
	 &('stakeholder'  stakeholderReference+=[org::Stakeholder|QualifiedName] (',' stakeholderReference+=[org::Stakeholder|QualifiedName])*)?
	 &('see' 'goal'  stakeholderRequirementReference+=[Goal|QualifiedName] (',' stakeholderRequirementReference+=[Goal|QualifiedName])*)?
	 &('see' 'requirement'  systemRequirementReference+=[ContractualElement|QualifiedName] (',' systemRequirementReference+=[ContractualElement|QualifiedName])*)?
	 &('see' 'document'  docReference+=ExternalDocument (',' docReference+=ExternalDocument)*)? 
	)
	 ']';


// requirement without target acts as a general requirement/constraint
// becomes a "global" constraint that still takes model elements that are supplied by query 	
Requirement:
	'requirement'  name=ID   
	(':'  title=ValueString)? 
	( 'for' target=[aadl2::NamedElement|ID] 
//		('of' targetContext=[aadl2::Classifier|AadlClassifierReference])?
	)?
'['	(
 	('category'  category=[categories::RequirementCategory|CatRef] )?
	&('description'  description=Description)? 
	&('constants' constants+=FinalValue+)?
	&('assert'  assert=PredicateExpression)?  // predicate expression 
	&('rationale'  rationale=STRING)? 
	&('see' 'goal'  goalReference+=[Goal|QualifiedName] (',' goalReference+=[Goal|QualifiedName])*)?
	&('refined' 'to' refinedReference+=[Requirement|QualifiedName](',' refinesReference+=[Requirement|QualifiedName])*)? 
	 &( subrequirement+=Requirement*) 
	&('decomposed' 'to' decomposedReference+=[Requirement|QualifiedName](',' decomposesReference+=[Requirement|QualifiedName])*)? 
	&('evolves'  evolvesReference+=[Requirement|QualifiedName](',' evolvesReference+=[Requirement|QualifiedName])*)? 
	&('see' 'goal'  stakeholderRequirementReference+=[Goal|QualifiedName] (',' stakeholderRequirementReference+=[Goal|QualifiedName])*)?
	&('see' 'requirement'  systemRequirementReference+=[ContractualElement|QualifiedName] (',' systemRequirementReference+=[ContractualElement|QualifiedName])*)?
	&('see' 'document'  docReference+=ExternalDocument (',' docReference+=ExternalDocument)*)? 
	)
	']';

	
// TODO reference to EMV2 construct: namedelement has hazard property or should be a EMV2 reference	
Hazard:
	'hazard'  name=ID   
	(':'  title=ValueString)? 
	(( 'for' target=[aadl2::NamedElement|ID] 
//		('of' targetContext=[aadl2::Classifier|AadlClassifierReference])?
	)?
 	'['
 	('category'  category=[categories::HazardCategory|CatRef])?
	&('description'  description=Description)? 
	&('mitigated' 'by' hazardReference+=[Requirement|QualifiedName] (',' hazardReference+=[Requirement|QualifiedName])*)? 
	&('rationale'  rationale=STRING)? 
	)
	']';


ExternalDocument : 
	docReference=DOCPATH ( '#' docFragment=DOCFRAGMENT)?
;


// path to external document and its fragment
DOCPATH: ( ID '/')* ID '.' ID;

DOCFRAGMENT: ID ('.' ID)*;


	