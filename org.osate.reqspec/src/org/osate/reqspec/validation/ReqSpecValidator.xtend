/*
 * generated by Xtext
 */
package org.osate.reqspec.validation
import org.eclipse.xtext.validation.Check
import org.osate.reqspec.reqSpec.Goal
import org.osate.reqspec.reqSpec.ReqSpecPackage
import org.osate.reqspec.reqSpec.Requirement
import org.osate.reqspec.reqSpec.ReqDocument
import org.osate.reqspec.reqSpec.ContractualElement
import org.eclipse.emf.common.util.BasicEList
import static extension org.osate.reqspec.util.ReqSpecUtilExtension.*
import org.osate.aadl2.Classifier
import org.osate.reqspec.reqSpec.DocumentSection
import org.eclipse.xtext.validation.CheckType
import org.osate.aadl2.NamedElement
import org.osate.reqspec.reqSpec.SystemRequirements
import org.osate.reqspec.reqSpec.StakeholderGoals
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.emf.ecore.util.EcoreUtil
import org.osate.alisa.common.scoping.CommonGlobalScopeProvider
import com.google.inject.Inject

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ReqSpecValidator extends AbstractReqSpecValidator {

  public static val MISSING_STAKEHOLDER = 'missingStakeholder'
  public static val MISSING_STAKEHOLDER_GOAL = 'missingStakeholderGoal'
  public static val MULTIPLE_CLASSIFIERS = 'multipleClassifiers'
  public static val FEATURES_WITHOUT_REQUIREMENT = 'featuresWithoutRequirement'
  public static val DUPLICATE_GOAL_WITHIN_STAKEHOLDER_GOALS = 'org.osate.reqspec.validation.duplicate.goal.within.stakeholdergoals'
  public static val DUPLICATE_STAKEHOLDER_GOALS = 'org.osate.reqspec.validation.duplicate.stakeholdergoals'
  public static val REQSPEC_FOR_DIFFERS_FROM_STAKEHOLDERGOALS_FOR = 'org.osate.reqspec.validation.reqspec.for.differs.from.stakeholdergoals.for'
  public static val GOAL_REFERENCE_NOT_FOUND = 'org.osate.reqspec.validation.goal.reference.not.found'

	@Inject
	CommonGlobalScopeProvider cgsp
	
	@Check//(CheckType.EXPENSIVE)
	def void checkMissingStakeholder(Goal goal) {
		if (goal.stakeholderReference.empty) {
			if (goal.refinesReference.empty){
			warning('Goal should have stakeholders', 
					ReqSpecPackage.Literals.GOAL__STAKEHOLDER_REFERENCE,
					MISSING_STAKEHOLDER)
			} else {
				goal.refinesReference.forEach[checkMissingStakeholder]
			}		
		}
	}
	
	@Check//(CheckType.EXPENSIVE)
	def void checkMissingGoal(Requirement req) {
		if (req.goalReference.empty  && req.stakeholderRequirementReference.empty) {
			if (req.refinesReference.empty){ 
			warning('System requirement should have stakeholder goal or requirement reference', 
					ReqSpecPackage.Literals.REQUIREMENT__GOAL_REFERENCE,
					MISSING_STAKEHOLDER_GOAL)
			} else {
				req.refinesReference.forEach[checkMissingGoal]
			}		
		}
	}

	
	@Check(CheckType.EXPENSIVE)
	def void checkMultipleSystems(ReqDocument reqdoc) {
		val syslist = new BasicEList<Classifier>
		reqdoc.content.forEach[e | if (e instanceof ContractualElement) syslist += e.targetClassifier]
		if (syslist.size > 1){
			val cls = syslist.map[name].reduce[p1, p2| p1 + ' ' + p2]
			warning('Requirements cover multiple classifiers: '+cls, 
					ReqSpecPackage.Literals.REQ_DOCUMENT__CONTENT,
					MULTIPLE_CLASSIFIERS)
		}
	}
	
		@Check(CheckType.EXPENSIVE)
	def void checkMultipleSystems(DocumentSection docsection) {
		val syslist = new BasicEList<Classifier>
		docsection.content.forEach[e | if (e instanceof ContractualElement) syslist += e.targetClassifier]
		if (!syslist.empty){
			val cls = syslist.map[name].reduce[p1, p2| p1 + ' ' + p2]
			warning('Requirements cover multiple classifiers: '+cls, 
					ReqSpecPackage.Literals.DOCUMENT_SECTION__CONTENT,
					MULTIPLE_CLASSIFIERS)
		}
	}
	
		@Check(CheckType.EXPENSIVE)
	def void checkFeatureCoverage(SystemRequirements sysreqs) {
		val cl = sysreqs.target
		if (cl == null || cl.getAllFeatures.empty ) return
		
		val fealist = new BasicEList<NamedElement>
		cl.getAllFeatures.forEach[e| if (!sysreqs.content.exists[r| r.targetElement == e ]) fealist += e]
		if (!fealist.empty){
			val fls = sysreqs.content.map[name].reduce[p1, p2| p1 + ' ' + p2]
			warning('Features without requirement: '+fls, 
					ReqSpecPackage.Literals.SYSTEM_REQUIREMENTS__CONTENT,
					FEATURES_WITHOUT_REQUIREMENT)
		}
	}
	
	
		@Check(CheckType.NORMAL)
	def void checkDuplicateGoal(StakeholderGoals stakeHolderGoals) {
		stakeHolderGoals.content.forEach[goal | 
			if (stakeHolderGoals.content.filter[name == goal.name].size > 1) 
				error("Duplicate goal name '" + goal.name + "' in StakeholderGoals '" + stakeHolderGoals.name + "'",  
					goal, ReqSpecPackage.Literals.CONTRACTUAL_ELEMENT__NAME,
					DUPLICATE_GOAL_WITHIN_STAKEHOLDER_GOALS, EcoreUtil.getURI(stakeHolderGoals).toString()
				)
		] 
	}

	@Check(CheckType.NORMAL)
	def void checkDuplicateStakeholderGoals(StakeholderGoals shg) {
		val dupes = cgsp.getDuplicates(shg)
			if (dupes.size > 0) {
				val node = NodeModelUtils.getNode(shg);
				error("Duplicate StakeholderGoal name '" + shg.name + "'",  
					shg, ReqSpecPackage.Literals.STAKEHOLDER_GOALS__NAME,
					DUPLICATE_STAKEHOLDER_GOALS, "" + node.offset, "" + node.length)
			}
	}
	
	@Check(CheckType.FAST)
	def void checkSpecGoalTargetConsistency(SystemRequirements sysReqs) {
		val reqSpecTarget = sysReqs.target
		val requirements = sysReqs.content
		val resource = sysReqs.eResource();

		requirements.forEach[requirement | 
			val goalReferences = requirement.goalReference
			goalReferences.forEach[goalRef | 
				val goalRefResolved = 
					switch goalRef {
						case !goalRef.eIsProxy : goalRef
						case goalRef.eIsProxy && EcoreUtil.resolve(goalRef,  resource.resourceSet).eIsProxy : null
						default : EcoreUtil.resolve(goalRef,  resource.resourceSet)
					} as Goal
				if (goalRefResolved != null && goalRefResolved.targetClassifier != null 
					&& goalRefResolved.targetClassifier != reqSpecTarget){
						val goalTargetName = goalRefResolved.targetClassifier.name
						val goalTargetURI = EcoreUtil.getURI(goalRefResolved.targetClassifier).toString();
						error("System Requirement '" +  sysReqs.name + 
								"' is not for the same component as the StakeholderGoals that " +
								"holds the goal that corresponds to requirement '" + requirement.name + "'", sysReqs,  
								ReqSpecPackage.Literals.SYSTEM_REQUIREMENTS__TARGET, REQSPEC_FOR_DIFFERS_FROM_STAKEHOLDERGOALS_FOR,
								sysReqs.target.name, goalTargetName, goalTargetURI )
				}
				
			]
		]
	}
	
}
