grammar org.osate.verify.Verify with org.osate.alisa.common.Common

generate verify "http://www.osate.org/verify/Verify"

import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.osate.org/reqspec/ReqSpec" as ReqSpec
import  "http://www.osate.org/categories/Categories" as categories


Verification: contents+=(VerificationLibrary | VerificationPlan );

// plan for a classifier. WIll add import to allow for non-qualified requirement references
// Also allows for cross checking that we have covered requirements with claims
VerificationPlan :
	'plan' name=ID 
	'for' target=  [aadl2::ComponentClassifier|AadlClassifierReference]  //      [ReqSpec::SystemSpec|QualifiedName]
	'['
	('description' description=STRING)?
	(claims+=Claim)*
//	subPlans +=VerificationPlan*
	']'
;

VerificationLibrary returns VerificationLibrary:
	'library' name =ID 
	('for' target=[ReqSpec::Requirement|QualifiedName])?
	'[' (content+= ( VerificationActivity | VerificationMethod | VerificationFolder))*
	']'
	;

VerificationFolder returns VerificationFolder:
	'folder' label =ID 
	('for' target=[ReqSpec::Requirement|QualifiedName])?
	'[' (content+= ( VerificationActivity | VerificationMethod | VerificationFolder))*
	']'
	;
 VerificationContainer : VerificationLibrary | VerificationFolder;
 
 Claim :
 	'claim' name=ID 'for' requirement=[ReqSpec::Requirement|QualifiedName] 
 	'assert' assert=ArgumentExpr
	('rationale'  rationale=MultiLineString)? 
	('[' (subclaims+=Claim)* ']')?
 	;	

VerificationActivity:
	'activity' name=ID 'for' target=[aadl2::ComponentClassifier|AadlClassifierReference]
	// or should it be the requirement, which provides the predicate
	'['(('title'  title=ValueString)?
	&('description'  description=Description)?
 	&('category'  category=[categories::SelectionCategory|CatRef])?
	&('method'  method=[VerificationMethod|QualifiedName])?
//	('parameters'  verificationParameters+=([ElementReference])*)? 
// these are data parameters to the method in addition to what comes with the model
// and via the requirement (predicate/limit values
	)
	']'  
;
 

VerificationCondition:
	('assumption' {VerificationAssumption}| 'precondition' {VerificationPrecondition} )name=ID  
	'['( 
	('title'  title=ValueString)? 
	&('description'  description=Description)? 
	 &('assert'  assert=ArgumentExpr )? 
	&('met' 'by' metBy=[ReqSpec::Requirement|QualifiedName])?
	&('rationale'  rationale=MultiLineString)? 
	&('issues'  issue+=MultiLineString (','issue+=MultiLineString)* )? 
	)
	']';
  	


ArgumentExpr:
	AllEvidenceExpr
;


AllEvidenceExpr returns ArgumentExpr:
	'all'{AllExpr} '[' all+=AndThenEvidenceExpr ( ',' all+=AndThenEvidenceExpr)* ']'
;

AndThenEvidenceExpr returns ArgumentExpr:
	FailThenEvidenceExpr (=>({AndThenExpr.left=current} op='andthen') right=AndThenEvidenceExpr)*
;

// Execute as alternative if the first one fails.
// The results of both are reported
FailThenEvidenceExpr returns ArgumentExpr:
	AtomicEvidenceExpr (=>({FailThenExpr.left=current} op='failthen') right=FailThenEvidenceExpr)*
;

AtomicEvidenceExpr returns ArgumentExpr:
	ConditionalEvidence
	| '(' AndThenEvidenceExpr ')' | AllEvidenceExpr 
;


ConditionalEvidence returns ArgumentExpr:
	VAReference (=>({ConditionalExpr.verification=current} op='when')  condition=OrConditionExpr )?
;

VAReference returns ArgumentExpr:
	{RefExpr} verification=[VerificationActivity|QualifiedName]
	('weight' weight=INT )?
;


OrConditionExpr returns ConditionExpr:
		AndConditionExpr (=>({ConditionExpr.left=current} op='or') right=AndConditionExpr)*
;

AndConditionExpr returns ConditionExpr:
	AtomicConditionExpr (=>({ConditionExpr.left=current} op='and') right=AtomicConditionExpr)*
;

AtomicConditionExpr:
	cat=[categories::VerificationCategory|CatRef]
;


// need to distinguish between method with/out predicate
// method producing multiple results
// Java based methods: all
// interface methods to external or built-in

VerificationMethod:
	'method' name=ID (':'  title=ValueString)?
	'['
 	 methodType=SupportedTypes method = ValueString
 	 // parameters (in addition to the model element
	(('description'  description=Description)?
 	&('category'  category=[categories::VerificationCategory|CatRef])?
	&(conditions+=VerificationCondition)*
 	)
 	']'
;

enum SupportedTypes	:
	SINGLEPREDICATE = "singlepredicate" | SINGLEANALYSIS = "singleanalysis" |
	MULTIPREDICATE = "multipredicate" | MULTIANALYSIS = "multianalysis" 
	
//	XTEND = "Xtend" | LUTE = "lute" | AGREE= "agree" 
;