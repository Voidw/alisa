grammar org.osate.verify.Verify with org.osate.alisa.common.Common

generate verify "http://www.osate.org/verify/Verify"
import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.osate.org/reqspec/ReqSpec" as ReqSpec
import "http://www.osate.org/categories/Categories" as categories
import "http://www.osate.org/alisa/common/Common" as common
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtype
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Verification:
	contents+=( VerificationPlan | VerificationMethodRegistry);

// plan for a classifier. Will add import to allow for non-qualified requirement references 
// Also allows for cross checking that we have covered requirements with claims
VerificationPlan:
	'verification' 'plan' name=ID (':' title=STRING)? 
	'for' target=[aadl2::ComponentClassifier|AADLCLASSIFIERREFERENCE] //      [ReqSpec::SystemSpec|QualifiedName]
	'['
	(
		( description=Description)?
	& claim+=Claim*
	& (rationale=Rationale)?
	& ('assume' verifiedAssumption+=[VerificationPlan|QualifiedName]+)?
	& ('issues' issues+=STRING+ )?
	)
	']';

Claim:
	'claim' requirement=[ReqSpec::Requirement|QualifiedName]  (':' title=STRING)?
	( '(' weight=Number ')' )?
	'['
	(
		('activities' activities += VerificationActivity)
		&('assert' assert=ArgumentExpr)
	& ('argument' argument=STRING )?//( argumentUncertainty=Uncertainty)? )?
	& (rationale=Rationale)?
	& (subclaim+=Claim)*
	& ('issues' issues+=STRING+ )?
	)  
	']';
//
//VerificationLibrary returns VerificationLibrary:
//	'library' name=ID (':' title=STRING)?
//	('for' target=[aadl2::ComponentClassifier|AADLCLASSIFIERREFERENCE])?
//	'['
//	( ( description=Description)?
//	&(content+=(VerificationActivity |  VerificationFolder))*
//	)
//	']';


VerificationActivityParameter: 
		compute=[common::ComputeDeclaration|ID]
;

VerificationActivity:
	name=ID ':'
	(
	   method=[VerificationMethod|QualifiedName] '(' (parameters+=ID (',' parameters+=ID)*)?')'
	('timeout' timeout=INT)?
	//	('parameters'  verificationParameters+=([ElementReference])*)? 
	// these are data parameters to the method in addition to what comes with the model
)
	;
	
//	VMParameter:
//		{VMParameter} value = [xbase::XVariableDeclaration|ID]
//	;

VerificationCondition:
	('validation' {VerificationValidation} | 'precondition' {VerificationPrecondition}) name=ID
	(':' title=STRING)?
	'[' (
	 ( description=Description)?
	&('method' method=[VerificationMethod|QualifiedName]('as' computeVariable=[common::ComputeDeclaration|ID])?)?
	& (rationale=Rationale)?
	)
	']';

ArgumentExpr:
	AllEvidenceExpr;

AllEvidenceExpr returns ArgumentExpr:
	'all' {AllExpr} '[' all+=AndThenEvidenceExpr (',' all+=AndThenEvidenceExpr)* ']';

AndThenEvidenceExpr returns ArgumentExpr:
	FailThenEvidenceExpr (=> ({AndThenExpr.left=current} 'andthen') right=AndThenEvidenceExpr)*;

	// Execute as alternative if the first one fails.
// The results of both are reported
FailThenEvidenceExpr returns ArgumentExpr:
	AtomicEvidenceExpr (=> ({FailThenExpr.left=current} (failed?='failthen'|unknown?='unknownthen')) right=FailThenEvidenceExpr)*;

AtomicEvidenceExpr returns ArgumentExpr:
	ConditionalEvidence
	| '(' AndThenEvidenceExpr ')' | AllEvidenceExpr;

ConditionalEvidence returns ArgumentExpr:
	VAReference (=> ({WhenExpr.verification=current} 'when') condition+=[categories::VerificationCategory|ID]+)?; // should it be a selection category as well

VAReference returns ArgumentExpr:
	{RefExpr} verification=[VerificationActivity|QualifiedName]
	('(' weight=INT ')')?;

VerificationMethodRegistry returns VerificationMethodRegistry:
	'verification' 'methods' name=ID
	(':' title=STRING)?
	'[' (
	( description=Description)?
	methods+=VerificationMethod*)
	']';

VerificationMethodParameter:
	name=ID
;

VerificationMethod:
	'method' name=ID ('(' (params+=ID (',' params+=ID)*)? ')' )? (':' title=STRING)?
	'['
	(
	(methodType=SupportedTypes scope=SupportedScopes (reporting=SupportedReporting)?)
	&( description=Description)?
	&('path' methodPath=STRING)?
	& (conditions+=VerificationCondition)*
	// parameters (in addition to the model element
	& ('category' category+=[categories::VerificationCategory|ID]+)?
	)
	']';

enum SupportedTypes:
	ANALYSIS='analysis' | PREDICATE='predicate' | COMPUTE='compute' 
	| RESOLUTEPROVE='resoluteprove' | RESOLUTECOMPUTE='resolutecompute' 
	| RESOLUTEPREDICATE='resolutepredicate'| MANUAL='manual';
	
enum SupportedScopes: SELF='self' | PARTS='parts' | ALL='all';

enum SupportedReporting: MARKER='marker' |ERRORMARKER='errormarker' | DIAGNOSTICS='diagnostics'| ASSERTEXCEPTION='assertexception'|RESULTREPORT='resultreport' ;