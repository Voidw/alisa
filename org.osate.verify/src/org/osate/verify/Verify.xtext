grammar org.osate.verify.Verify with org.osate.alisa.common.Common

generate verify "http://www.osate.org/verify/Verify"
import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.osate.org/reqspec/ReqSpec" as ReqSpec
import "http://www.osate.org/categories/Categories" as categories
import "http://www.osate.org/alisa/common/Common" as common
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtype
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Verification:
	contents+=	( VerificationPlan | VerificationMethodRegistry);

// plan for a classifier. Will add import to allow for non-qualified requirement references 
// Also allows for cross checking that we have covered requirements with claims
VerificationPlan:
	'verification' 'plan' name=ID (':' title=STRING)? 
	'for' systemRequirements=[ReqSpec::SystemRequirements|ID]  
	'['
	(
		( description=Description)?
	& claim+=Claim*
	& rationale=Rationale?
	& ('issues' issues+=STRING+ )?
	)
	']';

Claim:
	'claim' requirement=[ReqSpec::Requirement|QualifiedName]  (':' title=STRING)?
	( '(' weight=Number ')' )?
	'['
	(
		('activities' activities += VerificationActivity+)
		&('assert' assert=ArgumentExpr)
	& rationale=Rationale?
	& subclaim+=Claim*
	& ('issues' issues+=STRING+ )?
	)  
	']';


VerificationActivity:
	name=ID  ( ':' title=STRING)? 
	('for' target=[aadl2::ComponentImplementation|AADLCLASSIFIERREFERENCE])? // for specific AADL model configuration
	':' (
		( result+=[common::ComputeDeclaration|ID] (',' result+=[common::ComputeDeclaration|ID])* '=')?
	   method=[VerificationMethod|QualifiedName] '(' (parameters+=[xbase::XExpression| ID] (',' parameters+=[xbase::XExpression| ID])*)?')'
	('timeout' timeout=INT)?
)
	;

ArgumentExpr:
	ThenEvidenceExpr;

ThenEvidenceExpr returns ArgumentExpr:
	ElseEvidenceExpr (=> ({ThenExpr.left=current} 'then') successor=ThenEvidenceExpr)*;

	// Execute as alternative if the first one fails.
// The results of both are reported
ElseEvidenceExpr returns ArgumentExpr:
	SingleElseEvidenceExpr | CompositeElseEvidenceExpr
;
	
SingleElseEvidenceExpr returns ArgumentExpr:	
	SingleEvidenceExpr (=> ({ElseExpr.left=current} 'else') 
		(other=ElseEvidenceExpr | 
				'[' ('fail' ':' fail=ThenEvidenceExpr)? ('timeout' ':' timeout=ThenEvidenceExpr)? 
				('other' ':' other=ThenEvidenceExpr)? 
				 ']'
		)
	)*
	;

CompositeElseEvidenceExpr returns ArgumentExpr:	
	CompositeEvidenceExpr (=> ({ElseExpr.left=current} 'else') 
		other=ElseEvidenceExpr 
	)*
	;


QuantifiedEvidenceExpr returns ArgumentExpr:
	 'all' {AllExpr} '[' elements+=ThenEvidenceExpr (',' elements+=ThenEvidenceExpr)* ']' ;


CompositeEvidenceExpr returns ArgumentExpr:
	 '(' ThenEvidenceExpr ')' | QuantifiedEvidenceExpr;

SingleEvidenceExpr returns ArgumentExpr:
	VAReference (=> ({WhenExpr.verification=current} 'when') condition+=[categories::VerificationCategory|ID]+)?; // should it be a selection category as well

VAReference returns ArgumentExpr:
	{RefExpr} verification=[VerificationActivity|QualifiedName]
	('(' weight=INT ')')?;

//ConditionalEvidenceExpr returns ArgumentExpr:
//	AtomicEvidenceExpr ( => 
//		( => ({ConditionalEvidenceExpr.condition=current} 'else' 
//			(alternative=ConditionalElseExpr |
//				'[' ('fail' ':' fail=ConditionalEvidenceExpr)? ('timeout' ':' timeout=ConditionalEvidenceExpr)? 
//				('other' ':' other=ConditionalEvidenceExpr)? 
//				 ']'
//			)
//		))
//		|
//		(  {ConditionalEvidenceExpr.condition=current} 'then' successor=ConditionalThenExpr
//		( => 'else' 
//			(alternative=ConditionalElseExpr |
//				'[' ('fail' ':' fail=ConditionalEvidenceExpr)? ('timeout' ':' timeout=ConditionalEvidenceExpr)? 
//				('other' ':' other=ConditionalEvidenceExpr)? 
//				 ']'
//			)
//		)?) 
//	)?
//;
//
//ConditionalThenExpr returns ArgumentExpr:
//	AtomicEvidenceExpr ( => (  {ConditionalEvidenceExpr.condition=current} 'then' successor=ConditionalThenExpr
//		( => 'else' 
//			(alternative=ConditionalElseExpr |
//				'[' ('fail' ':' fail=ConditionalEvidenceExpr)? ('timeout' ':' timeout=ConditionalEvidenceExpr)? 
//				('other' ':' other=ConditionalEvidenceExpr)? 
//				 ']'
//			)
//		)?) 
//	)?
//;
//
//
//ConditionalElseExpr returns ArgumentExpr:
//	AtomicEvidenceExpr ( =>  (  {ConditionalEvidenceExpr.condition=current} 'else' 
//			(alternative=ConditionalElseExpr |
//				'[' ('fail' ':' fail=ConditionalEvidenceExpr)? ('timeout' ':' timeout=ConditionalEvidenceExpr)? 
//				('other' ':' other=ConditionalEvidenceExpr)? 
//				 ']'
//			)
//		)
//	)?
//;



VerificationMethodRegistry returns VerificationMethodRegistry:
	'verification' 'methods' name=ID
	(':' title=STRING)?
	'[' (
	( description=Description)?
	methods+=VerificationMethod*)
	']';

VerificationMethod:
	'method' name=ID ('(' (params+=FullJvmFormalParameter (',' params+=FullJvmFormalParameter)*)? ')' 
		(isPredicate?='boolean'|isResultReport?='report')?
	)? 
	(':' title=STRING)?
	'['
	(
	methodType=SupportedTypes 
	& description=Description?
	&('path' methodPath=STRING)?
	& condition=VerificationCondition?
	& ('category' category+=[categories::VerificationCategory|ID]+)?
	)
	']';


VerificationCondition:
	('validation' {VerificationValidation} | 'precondition' {VerificationPrecondition}) 
 	 name=ID
	(':' title=STRING)?
	'[' (
	 ( description=Description)?
	 &  (method=[VerificationMethod|QualifiedName] '(' (parameters+=[xbase::XExpression| ID] (',' parameters+=[xbase::XExpression| ID])*)?')'
	('timeout' timeout=INT)?)
	& rationale=Rationale?
	)
	']';

enum SupportedTypes:
	ANALYSISPLUGIN='analysisplugin'  
	| RESOLUTE='resolute' | JAVA='java' 
	| MANUAL='manual';
	
//enum SupportedScopes: SELF='self' | PARTS='parts' | ALL='all';

//enum SupportedReporting: MARKER='marker' |ERRORMARKER='errormarker' | DIAGNOSTICS='diagnostics'| ASSERTEXCEPTION='assertexception'|RESULTREPORT='resultreport' ;