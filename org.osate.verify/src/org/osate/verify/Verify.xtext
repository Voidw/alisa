grammar org.osate.verify.Verify with org.osate.alisa.common.Common

generate verify "http://www.osate.org/verify/Verify"
import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.osate.org/reqspec/ReqSpec" as ReqSpec
import "http://www.osate.org/categories/Categories" as categories
import "http://www.osate.org/alisa/common/Common" as common

Verification:
	contents+=(VerificationLibrary | VerificationPlan | VerificationMethodRegistry);

	// plan for a classifier. Will add import to allow for non-qualified requirement references
// Also allows for cross checking that we have covered requirements with claims
VerificationPlan:
	'plan' name=ID (':' title=STRING)? 
	'for' target=[aadl2::ComponentClassifier|AadlClassifierReference] //      [ReqSpec::SystemSpec|QualifiedName]
	'['
	(
		('description' description=STRING)?
	& claim+=Claim*
	& ('rationale' rationale=STRING)?
	& ('plan' 'assumption' planAssumption+=[VerificationPlan|QualifiedName]+)?
	)
	']';

Claim:
	'claim' name=ID (':' title=STRING)?
	( '(' weight=INT ')' )?
	'for' requirement=[ReqSpec::Requirement|QualifiedName]
	'['
	('assert' assert=ArgumentExpr
	& ('rationale' rationale=STRING)?
	& (subclaim+=Claim)*)  // if we have a requirement with refined requirements and we verify each
	']';

VerificationLibrary returns VerificationLibrary:
	'library' name=ID (':' title=STRING)?
	('for' target=[aadl2::ComponentClassifier|AadlClassifierReference])?
	'['
	( ('description' description=Description)?
	&(content+=(VerificationActivity |  VerificationFolder))*
	)
	']';

VerificationFolder returns VerificationFolder:
	'folder' label=ID
	'[' (content+=(VerificationActivity | VerificationFolder))*
	']';

VerificationContainer:
	VerificationLibrary | VerificationFolder;

VerificationActivity:
	'activity' name=ID (':' title=STRING)?
	('for' requirement=[ReqSpec::Requirement|QualifiedName] )?
	// or should it be the requirement, which provides the predicate
	'[' (
	('description' description=Description)?
//	&('category' category+=[categories::SelectionCategory|CatRef]+)?
	&('method' method=[VerificationMethod|QualifiedName]('as' computeVariable=[common::ComputeDeclaration|ID])?)
	&('timeout' timeout=INT)?
	//	('parameters'  verificationParameters+=([ElementReference])*)? 
	// these are data parameters to the method in addition to what comes with the model
	// and via the requirement (predicate/limit values
	&('rationale' rationale=STRING)?
)
	']';

VerificationCondition:
	('assumption' {VerificationAssumption} | 'precondition' {VerificationPrecondition}) name=ID
	(':' title=STRING)?
	'[' (
	 ('description' description=Description)?
	& ('assert' assert=ArgumentExpr)?
	& ('rationale' rationale=STRING)?
	)
	']';

ArgumentExpr:
	AllEvidenceExpr;

AllEvidenceExpr returns ArgumentExpr:
	'all' {AllExpr} '[' all+=AndThenEvidenceExpr (',' all+=AndThenEvidenceExpr)* ']';

AndThenEvidenceExpr returns ArgumentExpr:
	FailThenEvidenceExpr (=> ({AndThenExpr.left=current} 'andthen') right=AndThenEvidenceExpr)*;

	// Execute as alternative if the first one fails.
// The results of both are reported
FailThenEvidenceExpr returns ArgumentExpr:
	AtomicEvidenceExpr (=> ({FailThenExpr.left=current} 'failthen') right=FailThenEvidenceExpr)*;

AtomicEvidenceExpr returns ArgumentExpr:
	ConditionalEvidence
	| '(' AndThenEvidenceExpr ')' | AllEvidenceExpr;

ConditionalEvidence returns ArgumentExpr:
	VAReference (=> ({WhenExpr.verification=current} 'when') condition+=[categories::VerificationCategory|ID]+)?;

VAReference returns ArgumentExpr:
	{RefExpr} verification=[VerificationAction|QualifiedName]
	('(' weight=INT ')')?;

VerificationAction : VerificationActivity | VerificationMethod;

//SelectionCategoryReference:
//	cat=[categories::VerificationCategory|CatRef];

	// need to distinguish between method with/out predicate
// method producing multiple results
// Java based methods: all
// interface methods to external or built-in
VerificationMethodRegistry returns VerificationMethodRegistry:
	'registry' name=ID
	(':' title=STRING)?
	'[' (
	('description' description=STRING)?
	methods+=VerificationMethod*)
	']';

VerificationMethod:
	'method' name=ID (':' title=STRING)?
	('for' requirement=[ReqSpec::Requirement|QualifiedName] )?	
	'['
	(
	methodType=SupportedTypes methodPath=QualifiedName
	// parameters (in addition to the model element
	&('marker' marker=STRING)?
	&('description' description=STRING)?
	& ('category' category=[categories::VerificationCategory|ID])?
	& (conditions+=VerificationCondition)*
	)
	']';

enum SupportedTypes:
	SINGLEPREDICATE="singlepredicate" | SINGLEANALYSIS="singleanalysis" | ASSERTIONEXCEPTION="assertionexception"|
	MULTIMARKER="multimarker" | OWNMULTIMARKER="ownmultimarker" | MULTIDIAGNOSTICS="multidiagnostics" |RESULTREPORT="resultreport" 
	| RESOLUTEPROVE="resoluteprove"|MANUAL="manual";