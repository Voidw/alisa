grammar org.osate.verify.Verify with org.osate.alisa.common.Common

generate verify "http://www.osate.org/verify/Verify"
import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.osate.org/reqspec/ReqSpec" as ReqSpec
import "http://www.osate.org/categories/Categories" as categories
import "http://www.osate.org/alisa/common/Common" as common
 
Verification:
	contents+=(VerificationLibrary | VerificationPlan | VerificationMethodRegistry);

// plan for a classifier. Will add import to allow for non-qualified requirement references 
// Also allows for cross checking that we have covered requirements with claims
VerificationPlan:
	'plan' name=ID (':' title=STRING)? 
	'for' target=[aadl2::ComponentClassifier|AADLCLASSIFIERREFERENCE] //      [ReqSpec::SystemSpec|QualifiedName]
	'['
	(
		( description=Description)?
	& claim+=Claim*
	& (rationale=Rationale)?
	& ('assume' 'verified' verifiedAssumption+=[aadl2::ComponentClassifier|AADLCLASSIFIERREFERENCE]+)?
	)
	']';

Claim:
	'claim' name=ID (':' title=STRING)?
	( '(' weight=INT ')' )?
	'for' requirement=[ReqSpec::Requirement|QualifiedName]
	'['
	(('assure' assert=ArgumentExpr)
	& ('argument' argument=STRING ( argumentUncertainty=Uncertainty)? )?
	& (rationale=Rationale)?
	& (subclaim+=Claim)*)  // if we have a requirement with refined requirements and we verify each
	']';

VerificationLibrary returns VerificationLibrary:
	'library' name=ID (':' title=STRING)?
	('for' target=[aadl2::ComponentClassifier|AADLCLASSIFIERREFERENCE])?
	'['
	( ( description=Description)?
	&(content+=(VerificationActivity |  VerificationFolder))*
	)
	']';

VerificationFolder returns VerificationFolder:
	'folder' label=ID
	'[' (content+=(VerificationActivity | VerificationFolder))*
	']';

VerificationContainer:
	VerificationLibrary | VerificationFolder;

VerificationActivity:
	'activity' name=ID (':' title=STRING)?
	('for' requirement=[ReqSpec::Requirement|QualifiedName] )?
	// or should it be the requirement, which provides the predicate
	'[' (
	( description=Description)?
//	&('category' category+=[categories::SelectionCategory|CatRef]+)?
	&('method' method=[VerificationMethod|QualifiedName]('as' computeVariable=[common::ComputeDeclaration|ID])?)
	&('timeout' timeout=INT)?
	//	('parameters'  verificationParameters+=([ElementReference])*)? 
	// these are data parameters to the method in addition to what comes with the model
	// and via the requirement (predicate/limit values
	&(rationale=Rationale)?
)
	']';

VerificationCondition:
	('validation' {VerificationValidation} | 'precondition' {VerificationPrecondition}) name=ID
	(':' title=STRING)?
	'[' (
	 ( description=Description)?
	&('method' method=[VerificationMethod|QualifiedName]('as' computeVariable=[common::ComputeDeclaration|ID])?)
	& (rationale=Rationale)?
	)
	']';

ArgumentExpr:
	AllEvidenceExpr;

AllEvidenceExpr returns ArgumentExpr:
	'all' {AllExpr} '[' all+=AndThenEvidenceExpr (',' all+=AndThenEvidenceExpr)* ']';

AndThenEvidenceExpr returns ArgumentExpr:
	FailThenEvidenceExpr (=> ({AndThenExpr.left=current} 'andthen') right=AndThenEvidenceExpr)*;

	// Execute as alternative if the first one fails.
// The results of both are reported
FailThenEvidenceExpr returns ArgumentExpr:
	AtomicEvidenceExpr (=> ({FailThenExpr.left=current} (failed?='failthen'|unknown?='unknownthen')) right=FailThenEvidenceExpr)*;

AtomicEvidenceExpr returns ArgumentExpr:
	ConditionalEvidence
	| '(' AndThenEvidenceExpr ')' | AllEvidenceExpr;

ConditionalEvidence returns ArgumentExpr:
	VAReference (=> ({WhenExpr.verification=current} 'when') condition+=[categories::VerificationCategory|ID]+)?;

VAReference returns ArgumentExpr:
	{RefExpr} verification=[VerificationActivity|QualifiedName]
	('(' weight=INT ')')?;

//VerificationAction : VerificationActivity | VerificationMethod;


	// need to distinguish between method with/out predicate
// method producing multiple results
// Java based methods: all
// interface methods to external or built-in
VerificationMethodRegistry returns VerificationMethodRegistry:
	'registry' name=ID
	(':' title=STRING)?
	'[' (
	( description=Description)?
	methods+=VerificationMethod*)
	']';

VerificationMethod:
	'method' name=ID (':' title=STRING)?
	('for' requirement=[ReqSpec::Requirement|QualifiedName] )?	
	'['
	(
	(methodType=SupportedTypes scope=SupportedScopes (reporting=SupportedReporting)?)
	&( description=Description)?
	&('path' methodPath=QualifiedName)?
	& (conditions+=VerificationCondition)*
	// parameters (in addition to the model element
	& ('category' category=[categories::VerificationCategory|ID])?
	)
	']';

enum SupportedTypes:
	ANALYSIS='analysis' | PREDICATE='predicate' | COMPUTE='compute' 
	| RESOLUTEPROVE='resoluteprove' | MANUAL='manual';
	
enum SupportedScopes: SELF='self' | PARTS='parts' | ALL='all';

enum SupportedReporting: MARKER='marker' |ERRORMARKER='errormarker' | DIAGNOSTICS='diagnostics'| ASSERTEXCEPTION='assertexception'|RESULTREPORT='resultreport' ;