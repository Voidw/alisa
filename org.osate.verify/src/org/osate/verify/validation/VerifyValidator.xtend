/*
 * generated by Xtext
 */
package org.osate.verify.validation

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import org.osate.verify.util.IVerifyGlobalReferenceFinder
import org.osate.verify.util.VerificationMethodDispatchers
import org.osate.verify.verify.Claim
import org.osate.verify.verify.JavaMethod
import org.osate.verify.verify.PluginMethod
import org.osate.verify.verify.Verification
import org.osate.verify.verify.VerificationActivity
import org.osate.verify.verify.VerificationCondition
import org.osate.verify.verify.VerificationMethodRegistry
import org.osate.verify.verify.VerificationPlan
import org.osate.verify.verify.VerifyPackage

import static org.osate.verify.util.VerifyUtilExtension.*
import org.osate.verify.verify.VerificationMethod
import org.osate.categories.categories.MethodCategory
import org.osate.categories.categories.QualityCategory
import org.osate.categories.categories.SelectionCategory
import org.osate.categories.categories.PhaseCategory

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class VerifyValidator extends AbstractVerifyValidator {

  public static val INCORRECT_METHOD_PATH = "org.osate.verify.incorrectMethodPath"
  public static val INCORRECT_METHOD_REFERENCE = "org.osate.verify.incorrectMethodReference"
  public static val MISSING_METHOD_REFERENCE = "org.osate.verify.missingMethodReference"
  public static val INCORRECT_METHOD_ID = "org.osate.verify.incorrectMethodID"
  public static val CLAIM_MISSING_REQUIREMENT = "org.osate.verify.claimMissingRequirement"
  public static val CLAIM_INVALID_REQUIREMENT = "org.osate.verify.claimInvalidRequirement"
  public static val MISSING_CLAIM_FOR_REQ = "org.osate.verify.missingClaimForReq"
  public static val CLAIM_REQ_FOR_NOT_VP_FOR = "org.osate.verify.claimReqForNotVpFor"
  public static val ILLEGAL_OBJECT_FOR_FILETYPE = "org.osate.verify.illegal.object.for.filetype"

	@Inject IVerifyGlobalReferenceFinder verifyGlobalRefFinder

	@Check
	def checkMethodPath(JavaMethod method) {
		val VerificationMethod vm = method.eContainer as VerificationMethod
		val result = VerificationMethodDispatchers.eInstance.methodExists(method, vm.params)
		if (result!=null) {
			warning("Could not find method: "+result, 
					VerifyPackage.Literals.JAVA_METHOD__METHOD_PATH,
					INCORRECT_METHOD_PATH)
		}
	}
	@Check
	def checkMethodID(PluginMethod method) {
		val result = VerificationMethodDispatchers.eInstance.dispatchVerificationMethod(method,null,null)
		if (result == null) {
			warning('Plugin verification method ID not found', 
					VerifyPackage.Literals.PLUGIN_METHOD__METHOD_ID,
					INCORRECT_METHOD_ID)
		}
	}

	@Check
	def checkMethodReference(VerificationCondition cond) {
		if (cond.method == null) {
			warning('Verification precondition or validation should have a verification method reference', 
					VerifyPackage.Literals.VERIFICATION_CONDITION__METHOD,
					MISSING_METHOD_REFERENCE)
		}
	}
	@Check
	def checkMissingMethodReference(VerificationActivity va) {
		if (va.method == null) {
			warning('Verification activity should have a method reference', 
					VerifyPackage.Literals.VERIFICATION_ACTIVITY__METHOD,
					MISSING_METHOD_REFERENCE)
		}
	}
	@Check
	def checkInvalidRequirementForClaim(Claim cl) {
		if (cl.requirement == null) {
			warning('Claim is missing requirement', 
					VerifyPackage.Literals.CLAIM__REQUIREMENT,
					CLAIM_MISSING_REQUIREMENT)
		}else{
			if(!containingVerificationPlan(cl).systemRequirements.content.contains(cl.requirement)){
				error('Requirement ' + cl.requirement.name + ' does not exist in ' + 
					containingVerificationPlan(cl).systemRequirements.name + '.', cl, VerifyPackage.Literals.CLAIM__REQUIREMENT,
					CLAIM_INVALID_REQUIREMENT
				)
			}
		}
	}
	
	@Check (CheckType.NORMAL)
	def checkClaimsForRequirement(VerificationPlan vp){
		val systemRequirements = vp.systemRequirements
		val requirements = systemRequirements.content
		requirements.forEach[req | 
			if( !vp.claim.exists[claim | claim.requirement === req]){
				error('No claim for requirement ' + req.name, vp,
					VerifyPackage.Literals.VERIFICATION_PLAN__NAME,
					MISSING_CLAIM_FOR_REQ, req.name, EcoreUtil.getURI(req).toString())
			}
		]
	}
	
	@Check (CheckType.FAST)
	def void checkFileTypeContents(Verification verification) {
		val verificationURI = EcoreUtil.getURI(verification)
		val fileExt = verificationURI.fileExtension.toLowerCase
		val contents = verification.contents
		switch fileExt{
			case "verify" : {
				contents.forEach[content |
					switch content {
						VerificationPlan : {}
						VerificationMethodRegistry : fileTypeError(fileExt, "verification methods", content)	
						default : fileTypeError(fileExt, content.class.name, content)
					}
				]
			}
			case "methodregistry" : {
				contents.forEach[content |
					switch content {
						VerificationMethodRegistry : {}
						VerificationPlan : fileTypeError(fileExt, "verification plan", content)	
						default : fileTypeError(fileExt, content.class.name, content)
					}
				]
			}
			default : {}
		}
	}	
	// TODO: This method overload calls the quickfix which does not work as expected, commenting out for the immediate future
//	def void fileTypeError(String fileType, String partName, EObject part, URI verificationURI){
//		error( partName +" not allowed in '"+ fileType + "' file.", part, null, ILLEGAL_OBJECT_FOR_FILETYPE, partName, verificationURI.toString())
//	}
	def void fileTypeError(String fileType, String partName, EObject part){
		warning( partName +" not allowed in '"+ fileType + "' file.", part, null)
	}
	
	@Check(CheckType.NORMAL)
	def void checkVerificationPlanUniqueToComponentClassifier(VerificationPlan vp) {
		val sysReq = vp.systemRequirements
		val vps = verifyGlobalRefFinder.getAllVerificationPlansForSystemRequirement(sysReq, vp)
		if (vps.size > 1){
			error("Other Verification Plans exist for '" +  sysReq.name + 
								"'. Only one Verification Plans is allowed for a specific System Requirements." , vp,  
								VerifyPackage.Literals.VERIFICATION_PLAN__SYSTEM_REQUIREMENTS)
		}
	}

	
		@Check(CheckType.FAST)
		def void checkRequirementCategory(VerificationMethod method) {
			val res = method.category.filter [ cat |
				!(cat instanceof MethodCategory || cat instanceof QualityCategory)
			]
			if(res.empty) return;
			error("Method '" + method.name + "' category '" + res +
				"' must be method or quality category.", method,
				VerifyPackage.Literals.VERIFICATION_METHOD__CATEGORY)
		}
	
		@Check(CheckType.FAST)
		def void checkRequirementCategory(VerificationActivity va) {
			val res = va.category.filter [ cat |
				!(cat instanceof SelectionCategory || cat instanceof PhaseCategory)
			]
			if(res.empty) return;
			error("Verification activity '" + va.name + "' category '" + res +
				"' must be phase or selection category.", va,
				VerifyPackage.Literals.VERIFICATION_ACTIVITY__CATEGORY)
		}
	
}
