import org.eclipse.emf.ecore.EObject
import org.osate.aadl2.Aadl2Factory
import org.osate.aadl2.AadlBoolean
import org.osate.aadl2.AadlInteger
import org.osate.aadl2.AadlReal
import org.osate.aadl2.AadlString
import org.osate.aadl2.BooleanLiteral
import org.osate.aadl2.IntegerLiteral
import org.osate.aadl2.ListType
import org.osate.aadl2.NumberType
import org.osate.aadl2.Property
import org.osate.aadl2.PropertyConstant
import org.osate.aadl2.PropertyExpression
import org.osate.aadl2.PropertyType
import org.osate.aadl2.RealLiteral
import org.osate.aadl2.StringLiteral
import org.osate.aadl2.UnitsType
import org.osate.alisa.common.common.ABinaryOperation
import org.osate.alisa.common.common.AExpression
import org.osate.alisa.common.common.AListTerm
import org.osate.alisa.common.common.AModelReference
import org.osate.alisa.common.common.APropertyReference
import org.osate.alisa.common.common.ComputeDeclaration
import org.osate.alisa.common.common.ModelRef
import org.osate.alisa.common.common.PropertyRef
import org.osate.alisa.common.common.TypeRef
import org.osate.alisa.common.common.ValDeclaration
import org.osate.alisa.common.validation.AbstractCommonValidator
import org.osate.alisa.common.common.CommonFactory

system org.osate.alisa.common.typing.CommonTypeSystem

validatorExtends AbstractCommonValidator

judgments {
	type |- EObject o : output PropertyType
		error 'cannot type ' + stringRep(o)
		source o
	assignable |- AExpression exp|> PropertyType target
		error stringRep(exp) + ' cannot be assigned to ' + stringRep(target)
		source exp
	compatible |- PropertyType left <: PropertyType right
		error stringRep(left) + ' is not compatible with ' + stringRep(right)
}

// type inference rules

rule ValDeclaration
  G |- ValDeclaration valDecl : PropertyType type
from {
	val declared = valDecl.getType()
	{
		declared != null
		G |- declared : type
	}
	or
	{
		// infer type from expression
		G |- valDecl.value : type
	}
}

rule ComputeDeclaration
  G |- ComputeDeclaration valDecl : PropertyType type
from {
	val declared = valDecl.getType()
	declared != null
	G |- declared : type
}


// type of property

axiom PropertyRef
	G |- PropertyRef propRef : propRef.ref.propertyType

axiom TypeRef
	G |- TypeRef typeRef : typeRef.ref

axiom PropertyType
	G |- PropertyType propType : propType


// binary operations

rule AExpression
	G |- PropertyExpression param : PropertyType type
from {
	type = Aadl2Factory.eINSTANCE.createAadlInteger
}
 
rule ABinaryExpression
	G |- ABinaryOperation binary : PropertyType type
from {
	G |- binary.left : var PropertyType leftType
	G |- binary.right : var PropertyType rightType
	val op = binary.operator
	switch op {
		case 'or', case 'and': {
				leftType instanceof AadlBoolean && rightType instanceof AadlBoolean
				type = leftType
			}
		case '==', case '!=': {
				leftType.eClass == rightType.eClass
				type = Aadl2Factory.eINSTANCE.createAadlBoolean
			}
		case '<', case '<=', case '>', case '>=': {
				leftType instanceof NumberType && rightType instanceof NumberType
				type = Aadl2Factory.eINSTANCE.createAadlBoolean
			}
		case '*', case '/', case '+', case '-': {
				leftType instanceof NumberType && rightType instanceof NumberType
				type = if (leftType instanceof AadlReal) leftType else rightType 
		}
	}
}


// compound types

rule AListTerm
	G |- AListTerm list : ListType type
from {
	type = Aadl2Factory.eINSTANCE.createListType
	var PropertyType elementType
	G |- list.elements.head : elementType
	type.ownedElementType = elementType // owned vs. referenced???
}

// simple types

axiom PropertyReference
	G |- APropertyReference ref : {
		val namedValue = ref.property
		if (namedValue instanceof Property) {
			namedValue.propertyType
		}	else if (namedValue instanceof PropertyConstant) {
			namedValue.propertyType
		} else {
			fail
		}
	}

// primitive types

axiom IntegerLiteral
	G |- IntegerLiteral value : {
		val intType = Aadl2Factory.eINSTANCE.createAadlInteger
		intType.referencedUnitsType = value.unit?.eContainer as UnitsType
		intType
	}

axiom RealLiteral
	G |- RealLiteral value : {
		val realType = Aadl2Factory.eINSTANCE.createAadlReal
		realType.referencedUnitsType = value.unit?.eContainer as UnitsType
		realType
	}

axiom BooleanLiteral
	G |- BooleanLiteral _ : Aadl2Factory.eINSTANCE.createAadlBoolean

axiom StringLiteral
	G |- StringLiteral _ : Aadl2Factory.eINSTANCE.createAadlString

axiom ModelReference
	G |- AModelReference _ : CommonFactory.eINSTANCE.createModelRef


// type compatibility

rule ExpressionAssignableToType
	G |- AExpression exp|> PropertyType type
from {
	var PropertyType expType
	G |- exp : expType
	G |- expType <: type
}

axiom PrimitiveString
	G |- AadlString left <: AadlString right

axiom PrimitiveBoolean
	G |- AadlBoolean left <: AadlBoolean right

rule PrimitiveNumber
	G |- NumberType left <: NumberType right
from {
	left.unitsType == right.unitsType
	left instanceof AadlInteger ||	right instanceof AadlReal
}

axiom ModelRef
	G |- ModelRef left <: ModelRef right

rule NotCompatible
	G |- PropertyType left <: PropertyType right
	error 'Types ' + stringRep(left) + ' and ' + stringRep(right) + ' are not compatible'
from {
	fail
}

// validation rules

checkrule CheckValDecls for 
	ValDeclaration valDecl
from {
	if (valDecl.getType() != null) {
	  empty |- valDecl : var PropertyType valType
  	empty |- valDecl.value : var PropertyType valueType
  	empty |- valueType <: valType
  }
}
