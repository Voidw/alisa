import org.eclipse.emf.ecore.EObject
import org.osate.aadl2.Aadl2Factory
import org.osate.aadl2.AadlBoolean
import org.osate.aadl2.AadlReal
import org.osate.aadl2.BooleanLiteral
import org.osate.aadl2.IntegerLiteral
import org.osate.aadl2.ListType
import org.osate.aadl2.NumberType
import org.osate.aadl2.Property
import org.osate.aadl2.PropertyExpression
import org.osate.aadl2.PropertyType
import org.osate.aadl2.RealLiteral
import org.osate.aadl2.StringLiteral
import org.osate.aadl2.UnitsType
import org.osate.alisa.common.common.ABinaryOperation
import org.osate.alisa.common.common.AListTerm
import org.osate.alisa.common.common.PropertyRef
import org.osate.alisa.common.common.TypeRef
import org.osate.alisa.common.common.ValDeclaration
import org.osate.alisa.common.validation.AbstractCommonValidator

system org.osate.alisa.common.typing.CommonTypeSystem

validatorExtends AbstractCommonValidator

judgments {
	type |- EObject o : output PropertyType
		error "cannot type " + stringRep(o)
		source o
}

rule ValDeclaration
  G |- ValDeclaration valDecl : PropertyType type
from {
	val declared = valDecl.getType()
	{
		declared != null
		G |- declared : type
	}
	or
	{
		// infer type from expression
		G |- valDecl.value : type
	}
}

rule AExpression
	G |- PropertyExpression param : PropertyType type
from {
	type = Aadl2Factory.eINSTANCE.createAadlInteger
}
 

// binary operations

rule ABinaryExpression
	G |- ABinaryOperation binary : PropertyType type
from {
	G |- binary.left : var PropertyType leftType
	G |- binary.right : var PropertyType rightType
	val op = binary.operator
	switch op {
		case 'or', case 'and': {
				leftType instanceof AadlBoolean && rightType instanceof AadlBoolean
				type = leftType
			}
		case '==', case '!=': {
				leftType.eClass == rightType.eClass
				type = Aadl2Factory.eINSTANCE.createAadlBoolean
			}
		case '<', case '<=', case '>', case '>=': {
				leftType instanceof NumberType && rightType instanceof NumberType
				type = Aadl2Factory.eINSTANCE.createAadlBoolean
			}
		case '*', case '/', case '+', case '-': {
				leftType instanceof NumberType && rightType instanceof NumberType
				type = if (leftType instanceof AadlReal) leftType else rightType 
		}
	}
}

// compound types

rule AListTerm
	G |- AListTerm list : ListType type
from {
	type = Aadl2Factory.eINSTANCE.createListType
	var PropertyType elementType
	G |- list.elements.head : elementType
	type.ownedElementType = elementType // owned vs. referenced???
}

// type of property

rule PropertyRef
	G |- PropertyRef propRef : PropertyType type
from {
	type = propRef.ref.propertyType
}

rule TypeRef
	G |- TypeRef typeRef : PropertyType type
from {
	type = typeRef.ref
}

rule PropertyType
	G |- PropertyType propType : PropertyType type
from {
	type = propType
}


// primitive types

axiom IntegerLiteral
	G |- IntegerLiteral value : {
		val intType = Aadl2Factory.eINSTANCE.createAadlInteger
		intType.referencedUnitsType = value.unit?.eContainer as UnitsType
		intType
	}

axiom RealLiteral
	G |- RealLiteral value : {
		val realType = Aadl2Factory.eINSTANCE.createAadlReal
		realType.referencedUnitsType = value.unit?.eContainer as UnitsType
		realType
	}

axiom BooleanLiteral
	G |- BooleanLiteral _ : Aadl2Factory.eINSTANCE.createAadlBoolean

axiom StringLiteral
	G |- StringLiteral _ : Aadl2Factory.eINSTANCE.createAadlString


