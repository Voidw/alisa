import org.eclipse.emf.ecore.EObject
import org.osate.aadl2.Aadl2Factory
import org.osate.aadl2.AadlBoolean
import org.osate.aadl2.AadlInteger
import org.osate.aadl2.AadlReal
import org.osate.aadl2.AadlString
import org.osate.aadl2.BooleanLiteral
import org.osate.aadl2.IntegerLiteral
import org.osate.aadl2.ListType
import org.osate.aadl2.NumberType
import org.osate.aadl2.Property
import org.osate.aadl2.PropertyConstant
import org.osate.aadl2.PropertyExpression
import org.osate.aadl2.PropertyType
import org.osate.aadl2.RealLiteral
import org.osate.aadl2.ReferenceType
import org.osate.aadl2.StringLiteral
import org.osate.aadl2.UnitsType
import org.osate.alisa.common.common.ABinaryOperation
import org.osate.alisa.common.common.AExpression
import org.osate.alisa.common.common.AModelReference
import org.osate.alisa.common.common.APropertyReference
import org.osate.alisa.common.common.AVariableReference
import org.osate.alisa.common.common.CommonFactory
import org.osate.alisa.common.common.ComputeDeclaration
import org.osate.alisa.common.common.ModelRef
import org.osate.alisa.common.common.PropertyRef
import org.osate.alisa.common.common.TypeRef
import org.osate.alisa.common.common.ValDeclaration
import org.osate.alisa.common.validation.AbstractCommonValidator

system org.osate.alisa.common.typing.CommonTypeSystem

validatorExtends AbstractCommonValidator



judgments {
	type |- EObject o : output PropertyType
		error 'cannot type ' + stringRep(o)
		source o
	assignable |- AExpression exp |> PropertyType target
		error stringRep(exp) + ' cannot be assigned to ' + stringRep(target)
		source exp
	compatible |- PropertyType left <: PropertyType right
		error stringRep(left) + ' is not compatible with ' + stringRep(right)
}

// type inference rules

rule ValDeclaration
  G |- ValDeclaration valDecl : PropertyType type
from {
	val declared = valDecl.getType()
	{
		declared != null
		G |- declared : type
	}
	or
	{
		// infer type from expression
		G |- valDecl.value : type
	}
}

rule ComputeDeclaration
  G |- ComputeDeclaration valDecl : PropertyType type
from {
	val declared = valDecl.getType()
	declared != null
	G |- declared : type
}


// type of property

axiom PropertyRef
	G |- PropertyRef propRef : propRef.ref.propertyType

axiom TypeRef
	G |- TypeRef typeRef : typeRef.ref

axiom PropertyType
	G |- PropertyType propType : propType


// binary operations

rule AExpression
	G |- PropertyExpression param : PropertyType type
	error 'typing: unhandled case' + stringRep(param)
	source param
from {
	fail
}
 
rule ABinaryExpression
	G |- ABinaryOperation binary : PropertyType type
	error 'typing: cannot determine type of expression'
	source binary
from {
	G |- binary.left : var PropertyType leftType
	G |- binary.right : var PropertyType rightType
	val op = binary.operator
	val leftUnit = null
	val rightUnit = null
	switch op {
		case OR, case AND,
		case EQ, case NEQ,
		case LT, case LEQ, case GT, case GEQ:
				type = Aadl2Factory.eINSTANCE.createAadlBoolean
		case PLUS, case MINUS, case MULT, case DIV: {
				if (leftType instanceof NumberType && rightType instanceof NumberType) {
					if (leftType instanceof AadlInteger && rightType instanceof AadlInteger) {
						type = leftType
					} else if (leftType instanceof AadlReal) {
						type = leftType
					} else {
						type = rightType
					}
				} else {
					fail	
				}
		}
	}
}


// compound types

// simple types

axiom PropertyReference
	G |- APropertyReference ref : {
		val namedValue = ref.property
		if (namedValue instanceof Property) {
			namedValue.propertyType
		}	else if (namedValue instanceof PropertyConstant) {
			namedValue.propertyType
		} else {
			fail
		}
	}

rule AVariableReference
	G |- AVariableReference vRef : PropertyType type
from {
	G |- vRef.variable : type
}

// primitive types

axiom IntegerLiteral
	G |- IntegerLiteral value : {
		val intType = Aadl2Factory.eINSTANCE.createAadlInteger
		intType.referencedUnitsType = value.unit?.eContainer as UnitsType
		intType
	}

axiom RealLiteral
	G |- RealLiteral value : {
		val realType = Aadl2Factory.eINSTANCE.createAadlReal
		realType.referencedUnitsType = value.unit?.eContainer as UnitsType
		realType
	}

axiom BooleanLiteral
	G |- BooleanLiteral _ : Aadl2Factory.eINSTANCE.createAadlBoolean

axiom StringLiteral
	G |- StringLiteral _ : Aadl2Factory.eINSTANCE.createAadlString

axiom ModelReference
	G |- AModelReference _ : CommonFactory.eINSTANCE.createModelRef


// type compatibility

rule ExpressionAssignableToType
	G |- AExpression exp|> PropertyType type
from {
	var PropertyType expType
	G |- exp : expType
	G |- expType <: type
}

axiom PrimitiveString
	G |- AadlString left <: AadlString right

axiom PrimitiveBoolean
	G |- AadlBoolean left <: AadlBoolean right

rule PrimitiveNumber
	G |- NumberType left <: NumberType right
from {
	left.unitsType == right.unitsType
	left instanceof AadlInteger ||	right instanceof AadlReal
}

axiom ModelRef
	G |- ModelRef left <: ModelRef right

axiom ModelRef1
	G |- ModelRef left <: ReferenceType right

rule NotCompatible
	G |- PropertyType left <: PropertyType right
	error 'types not compatible: cannot assign ' + stringRep(left) + ' to ' + stringRep(right)
from {
	fail
}

// validation rules

checkrule CheckValDecls for 
	ValDeclaration valDecl
from {
	if (valDecl.getType() != null) {
	  empty |- valDecl : var PropertyType valType
  	empty |- valDecl.value : var PropertyType valueType
  	empty |- valueType <: valType
  }
}

checkrule CheckExpressions for
	AExpression exp
from {
	
}