grammar org.osate.alisa.common.Common 
with org.eclipse.xtext.common.Terminals

generate common "http://www.osate.org/alisa/common/Common"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2
	
Description : 
	'description' description += DescriptionElement+
;

DescriptionElement :
 	text = STRING | showValue = ShowValue |thisTarget?='this'| image=ImageReference
 ;

Rationale: 'rationale' text=STRING ;


Uncertainty:
	'uncertainty' 
	'['
	(
		('volatility' volatility=INT)
		&('impact' impact=INT)
	)
	']'
;

// This is similar to diagnostics
ResultIssue returns ResultIssue:
	issueType=ResultIssueType
	message=STRING
	('target' target=[ecore::EObject|URIID])?
	('exception' exceptionType = STRING)?
	('diagnosticId' diagnosticId = STRING)?
	('[' issues+=ResultIssue*']')?
;


enum ResultIssueType:
	TBD = 'tbd'| ERROR='error' |  WARNING='warning' | INFO='info' | SUCCESS='success' | FAIL='fail' 
;

ValDeclaration returns AVariableDeclaration:
	 {ValDeclaration} 'val' (=> (type=ID name=ID) | name=ID) '=' right=AExpression  
	 ;

ComputeDeclaration returns AVariableDeclaration:
	{ComputeDeclaration}
	 'compute' (=> (type=ID name=ID) | name=ID) 
;

AModelOrPropertyReference returns AExpression:
	(AModelReference (=>({APropertyReference.modelElementReference=current} '@') property=[aadl2::AbstractNamedValue|AADLPROPERTYREFERENCE])? 
		) | APropertyReference
;

NestedModelelement returns NestedModelElement:
	modelElement=[aadl2::NamedElement|ID] ('.' next=NestedModelelement)?
;

AModelReference returns AModelReference:
	{AModelReference} 'this' ('.' next=NestedModelelement)?
;

APropertyReference returns APropertyReference:
	{APropertyReference}'@' property=[aadl2::AbstractNamedValue|AADLPROPERTYREFERENCE]
;

AVariableReference returns AExpression:
	{AVariableReference} variable=[AVariableDeclaration|ID]
;


 
 ShowValue returns ShowValue: ref=[AVariableDeclaration|ID] ('%' unit=[aadl2::UnitLiteral|ID])?;	

ImageReference : 'img' imgfile=IMGREF;

IMGREF : (ID '/')* ID '.' ID; 

// Expressions

AExpression returns aadl2::PropertyExpression: AOrExpression;

AOrExpression returns aadl2::PropertyExpression:
	AAndExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AAndExpression)*;

OpOr:
	'||';

AAndExpression returns aadl2::PropertyExpression:
	AEqualityExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=AEqualityExpression)*;

OpAnd:
	'&&';

AEqualityExpression returns aadl2::PropertyExpression:
	ARelationalExpression (=>({ABinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=ARelationalExpression)*;

OpEquality:
	'==' | '!=' ;

ARelationalExpression returns aadl2::PropertyExpression:
	AOtherOperatorExpression
	( =>({ABinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AOtherOperatorExpression)*;

OpCompare:
	'>=' | '<' '=' | '>' | '<' ;

AOtherOperatorExpression returns aadl2::PropertyExpression:
	AAdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
	rightOperand=AAdditiveExpression)*;

OpOther:
	  '->' 
	| '..<'
	| '>' '..'
	| '..'
	| '=>' 
	| '>' (=>('>' '>') | '>') 
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:';

AAdditiveExpression returns aadl2::PropertyExpression:
	AMultiplicativeExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=AMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

AMultiplicativeExpression returns aadl2::PropertyExpression:
	AUnaryOperation (=>({ABinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=AUnaryOperation)*;

OpMulti:
	'*' | '**' | '/' | '%';

AUnaryOperation returns aadl2::PropertyExpression:
	{AUnaryOperation} feature=OpUnary operand=AUnaryOperation | APrimaryExpression;

OpUnary:
	"!" | "-" | "+";
	
APrimaryExpression returns aadl2::PropertyExpression:
	ALiteral | AVariableReference | AModelOrPropertyReference |  AFunctionCall 
	| AParenthesizedExpression;

AFunctionCall returns aadl2::PropertyExpression:
	{AFunctionCall} function=ID '('functionCallArguments+=AExpression (',' functionCallArguments+=AExpression)* ')'
;

//AThis returns aadl2::PropertyExpression:
//	{AThis} 'this'
//;

ALiteral returns aadl2::PropertyExpression:
	ASetTerm | AListTerm |
	ABooleanLiteral |
	ARealTerm | AIntegerTerm |  
	ANullLiteral |
	StringTerm 
;

AIntegerTerm returns aadl2::IntegerLiteral:
	value=AInt (unit=[aadl2::UnitLiteral|ID])?
	;

AInt returns aadl2::Integer:
	INT ;

ARealTerm returns aadl2::RealLiteral:
	value=AReal (unit=[aadl2::UnitLiteral|ID])?
	;

AReal returns aadl2::Real:
	REAL_LIT ;

ANumericRangeTerm returns aadl2::RangeValue:
	minimum=NumAlt //(RealTerm|IntegerTerm| SignedConstant | ConstantValue)  
		'..' maximum=NumAlt//(RealTerm|IntegerTerm| SignedConstant | ConstantValue)
	( 'delta' delta=NumAlt//(RealTerm|IntegerTerm| SignedConstant | ConstantValue)
		
	)?
	;

NumAlt  returns aadl2::PropertyExpression: 
	ARealTerm|AIntegerTerm
;

ASetTerm returns aadl2::PropertyExpression:
	{ASetLiteral}  '#{' (elements+=AExpression (',' elements+=AExpression )*)? '}'
;

AListTerm returns aadl2::PropertyExpression:
	{AListTerm} '#[' (elements+=AExpression (',' elements+=AExpression )*)? ']'
;


AParenthesizedExpression returns aadl2::PropertyExpression:
	'(' AExpression ')';

ABooleanLiteral returns aadl2::PropertyExpression :
	  {aadl2::BooleanLiteral}(value?='true'|'false');


ANullLiteral returns aadl2::PropertyExpression :
	{ANullLiteral} 'null';


StringTerm returns aadl2::StringLiteral:
	value=NoQuoteString ;


NoQuoteString :
	// remove quotes from string in ValueConverter
	STRING
;


ComponentCategory returns aadl2::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'subprogram'
	| 'subprogram' 'group' | 'system' | 'thread' 'group'
	| 'thread' | 'virtual' 'bus' | 'virtual' 'processor';


terminal fragment
EXPONENT  :  ('e'|'E') ('+'|'-')? ( DIGIT )+  ;

terminal fragment
INT_EXPONENT :  ('e'|'E') ('+')? ( DIGIT )+ ;


terminal REAL_LIT : 	
	(DIGIT)+('_' (DIGIT)+)* ( '.' (DIGIT)+('_' (DIGIT)+)* ( EXPONENT )?)
  ;

//terminal INTEGER_LIT : 
//		(DIGIT)+('_' (DIGIT)+)*
//		(( '#' BASED_INTEGER  '#' ( INT_EXPONENT )? )
//			| (INT_EXPONENT)?
//		)
//  ;

terminal fragment
DIGIT     :  ( '0'..'9' ) ;

terminal fragment
EXTENDED_DIGIT     :  ( '0'..'9' | 'a'..'f' | 'A'..'F') ;

terminal fragment
BASED_INTEGER      :  ( EXTENDED_DIGIT ) ( ('_')? EXTENDED_DIGIT )* ;


// Qualified classifier reference
AadlClassifierReference:
	ID ('::' ID)+ ('.' ID)?;

AADLPROPERTYREFERENCE: ID ('::' ID)?;


URIID: STRING;

//terminal URIID : ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'#'|'@'|'/'|':')*;

QualifiedName: ID ('.' ID)*;

	
