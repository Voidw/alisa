<<<<<<< Upstream, based on develop
grammar org.osate.alisa.common.Common 
with org.eclipse.xtext.common.Terminals

generate common "http://www.osate.org/alisa/common/Common"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2
import  "http://www.osate.org/organization/Organization" as org


	
Description : 
	'description' description += DescriptionElement+
;

DescriptionElement :
 	text = STRING | showValue = ShowValue |thisTarget?='this'| image=ImageReference
 ;

Rationale: 'rationale' text=STRING ;


Uncertainty:
	'uncertainty' 
	'['
	(
		('volatility' volatility=Number)
		&('costimpact' costimpact=Number)
		&('scheduleimpact' scheduleimpact=Number)
		&('familiarity' familiarity=Number)
		&('timecriticality' timecriticality=Number)
		&('riskindex' riskindex=Number)
		&('maturityindex' maturityindex=Number)
	)
	']'
;

// New rule for val only
ValDeclaration returns AVariableDeclaration:
	 {ValDeclaration} 'val' (=> (type=ID name=ID) | name=ID) '=' (right=AExpression)?  
	 ;

ComputeDeclaration returns AVariableDeclaration:
	{ComputeDeclaration}
	 'compute' (=> (type=ID name=ID) | name=ID) 
;


APropertyReference returns AExpression:
	{APropertyReference} '@' property=[aadl2::Property|AADLPROPERTYREFERENCE]
;

AVariableReference returns AExpression:
	{AVariableReference} variable=[AVariableDeclaration|ID]
;


 
 ShowValue returns ShowValue: ref=[AVariableDeclaration|ID] ('%' unit=[aadl2::UnitLiteral|ID])?;	

ImageReference : 'img' imgfile=IMGREF;

IMGREF : (ID '/')* ID '.' ID; 

// Expressions

AExpression: AOrExpression;

AOrExpression returns AExpression:
	AAndExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AAndExpression)*;

OpOr:
	'||';

AAndExpression returns AExpression:
	AEqualityExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=AEqualityExpression)*;

OpAnd:
	'&&';

AEqualityExpression returns AExpression:
	ARelationalExpression (=>({ABinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=ARelationalExpression)*;

OpEquality:
	'==' | '!=' | '===' | '!==';

ARelationalExpression returns AExpression:
	AOtherOperatorExpression
	( =>({ABinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AOtherOperatorExpression)*;

OpCompare:
	'>=' | '<' '=' | '>' | '<' ;

AOtherOperatorExpression returns AExpression:
	AAdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
	rightOperand=AAdditiveExpression)*;

OpOther:
	  '->' 
	| '..<'
	| '>' '..'
	| '..'
	| '=>' 
	| '>' (=>('>' '>') | '>') 
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:';

AAdditiveExpression returns AExpression:
	AMultiplicativeExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=AMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

AMultiplicativeExpression returns AExpression:
	AUnaryOperation (=>({ABinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=AUnaryOperation)*;

OpMulti:
	'*' | '**' | '/' | '%';

AUnaryOperation returns AExpression:
	{AUnaryOperation} feature=OpUnary operand=AUnaryOperation | APrimaryExpression;

OpUnary:
	"!" | "-" | "+";
	
APrimaryExpression returns AExpression:
	ALiteral |
	AParenthesizedExpression;

ALiteral returns AExpression:
	ACollectionLiteral |
	ABooleanLiteral |
	ANumberLiteral |
	ANullLiteral |
	AStringLiteral 
;

ACollectionLiteral:
	ASetLiteral | AListLiteral
;

ASetLiteral:
	{ASetLiteral} '#' '{' (elements+=AExpression (',' elements+=AExpression )*)? '}'
;

AListLiteral:
	{AListLiteral} '#' '[' (elements+=AExpression (',' elements+=AExpression )*)? ']'
;


AParenthesizedExpression returns AExpression:
	'(' AExpression ')';

ABooleanLiteral returns AExpression :
	{ABooleanLiteral} ('false' | isTrue?='true');

ANullLiteral returns AExpression :
	{ANullLiteral} 'null';


ANumberLiteral returns ANumberLiteral :
	value=Number  (=>  unit=[aadl2::UnitLiteral|ID])?
	;


AStringLiteral returns AExpression:
	{AStringLiteral} value=STRING;


// Qualified classifier reference
AadlClassifierReference:
	ID ('::' ID)+ ('.' ID)?;

AADLPROPERTYREFERENCE: ID ('::' ID)?;


URIID: STRING;

QualifiedName: ID ('.' ID)*;

Number hidden():
HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

terminal HEX:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+ 
	('#' (('b'|'B')('i'|'I') | ('l'|'L')))?;
	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9'|'_')*; 	
terminal DECIMAL:
	INT 
	(('e'|'E') ('+'|'-')? INT)? 
	(('b'|'B')('i'|'I'|'d'|'D') | ('l'|'L'|'d'|'D'|'f'|'F'))?;
	
=======
grammar org.osate.alisa.common.Common 
with org.eclipse.xtext.common.Terminals

generate common "http://www.osate.org/alisa/common/Common"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2
import  "http://www.osate.org/organization/Organization" as org


	
Description : 
	'description' description += DescriptionElement+
;

DescriptionElement :
 	text = STRING | showValue = ShowValue |thisTarget?='this'| image=ImageReference
 ;

Rationale: 'rationale' text=STRING ;


Uncertainty:
	'uncertainty' 
	'['
	(
		('volatility' volatility=Number)
		&('costimpact' costimpact=Number)
		&('scheduleimpact' scheduleimpact=Number)
		&('familiarity' familiarity=Number)
		&('timecriticality' timecriticality=Number)
		&('riskindex' riskindex=Number)
		&('maturityindex' maturityindex=Number)
	)
	']'
;

// New rule for val only
ValDeclaration returns AVariableDeclaration:
	 {ValDeclaration} 'val' (=> (type=ID name=ID) | name=ID) '=' (right=AExpression)?  
	 ;

ComputeDeclaration returns AVariableDeclaration:
	{ComputeDeclaration}
	 'compute' (=> (type=ID name=ID) | name=ID) 
;


APropertyReference returns AExpression:
	{APropertyReference} '@' property=[aadl2::Property|AADLPROPERTYREFERENCE]
;

AVariableReference returns AExpression:
	{AVariableReference} variable=[AVariableDeclaration|ID]
;


 
 ShowValue returns ShowValue: ref=[AVariableDeclaration|ID] ('%' unit=[aadl2::UnitLiteral|ID])?;	

ImageReference : 'img' imgfile=IMGREF;

IMGREF : (ID '/')* ID '.' ID; 

// Expressions

AExpression: AOrExpression;

AOrExpression returns AExpression:
	AAndExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AAndExpression)*;

OpOr:
	'||';

AAndExpression returns AExpression:
	AEqualityExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=AEqualityExpression)*;

OpAnd:
	'&&';

AEqualityExpression returns AExpression:
	ARelationalExpression (=>({ABinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=ARelationalExpression)*;

OpEquality:
	'==' | '!=' | '===' | '!==';

ARelationalExpression returns AExpression:
	AOtherOperatorExpression
	( =>({ABinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AOtherOperatorExpression)*;

OpCompare:
	'>=' | '<' '=' | '>' | '<' ;

AOtherOperatorExpression returns AExpression:
	AAdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
	rightOperand=AAdditiveExpression)*;

OpOther:
	  '->' 
	| '..<'
	| '>' '..'
	| '..'
	| '=>' 
	| '>' (=>('>' '>') | '>') 
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:';

AAdditiveExpression returns AExpression:
	AMultiplicativeExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=AMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

AMultiplicativeExpression returns AExpression:
	AUnaryOperation (=>({ABinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=AUnaryOperation)*;

OpMulti:
	'*' | '**' | '/' | '%';

AUnaryOperation returns AExpression:
	{AUnaryOperation} feature=OpUnary operand=AUnaryOperation | APrimaryExpression;

OpUnary:
	"!" | "-" | "+";
	
APrimaryExpression returns AExpression:
	ALiteral | AVariableReference |
	AParenthesizedExpression;

ALiteral returns AExpression:
	ACollectionLiteral |
	ABooleanLiteral |
	ANumberLiteral |
	ANullLiteral |
	AStringLiteral 
;

ACollectionLiteral:
	ASetLiteral | AListLiteral
;

ASetLiteral:
	{ASetLiteral} '#' '{' (elements+=AExpression (',' elements+=AExpression )*)? '}'
;

AListLiteral:
	{AListLiteral} '#' '[' (elements+=AExpression (',' elements+=AExpression )*)? ']'
;


AParenthesizedExpression returns AExpression:
	'(' AExpression ')';

ABooleanLiteral returns AExpression :
	{ABooleanLiteral} ('false' | isTrue?='true');

ANullLiteral returns AExpression :
	{ANullLiteral} 'null';


ANumberLiteral returns ANumberLiteral :
	value=Number  (=>  unit=[aadl2::UnitLiteral|ID])?
	;


AStringLiteral returns AExpression:
	{AStringLiteral} value=STRING;


// Qualified classifier reference
AadlClassifierReference:
	ID ('::' ID)+ ('.' ID)?;

AADLPROPERTYREFERENCE: ID ('::' ID)?;


URIID: STRING;

QualifiedName: ID ('.' ID)*;

Number hidden():
HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

terminal HEX:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+ 
	('#' (('b'|'B')('i'|'I') | ('l'|'L')))?;
	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9'|'_')*; 	
terminal DECIMAL:
	INT 
	(('e'|'E') ('+'|'-')? INT)? 
	(('b'|'B')('i'|'I'|'d'|'D') | ('l'|'L'|'d'|'D'|'f'|'F'))?;
	
>>>>>>> d17345d completed resolving val and compute variables.
