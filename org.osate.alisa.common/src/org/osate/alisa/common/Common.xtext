grammar org.osate.alisa.common.Common 
with org.eclipse.xtext.common.Terminals

generate common "http://www.osate.org/alisa/common/Common"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://aadl.info/AADL/2.0" as aadl2
import  "http://www.osate.org/organization/Organization" as org


	
Description : 
	'description' description += DescriptionElement+
;

DescriptionElement :
 	text = STRING | showValue = ShowValue |thisTarget?='this'| image=ImageReference
 ;

Rationale: 'rationale' text=STRING ;


Uncertainty:
	'uncertainty' 
	'['
	(
		('volatility' volatility=Number)
		&('costimpact' costimpact=Number)
		&('scheduleimpact' scheduleimpact=Number)
		&('familiarity' familiarity=Number)
		&('timecriticality' timecriticality=Number)
		&('riskindex' riskindex=Number)
		&('maturityindex' maturityindex=Number)
	)
	']'
;

ValDeclaration returns AVariableDeclaration:
	 {ValDeclaration} 'val' (=> (type=ID name=ID) | name=ID) '=' (right=AExpression)?  
	 ;

ComputeDeclaration returns AVariableDeclaration:
	{ComputeDeclaration}
	 'compute' (=> (type=ID name=ID) | name=ID) 
;


APropertyReference returns AExpression:
	{APropertyReference} '@' property=[aadl2::AbstractNamedValue|AADLPROPERTYREFERENCE]
;

AVariableReference returns AExpression:
	{AVariableReference} variable=[AVariableDeclaration|ID]
;


 
 ShowValue returns ShowValue: ref=[AVariableDeclaration|ID] ('%' unit=[aadl2::UnitLiteral|ID])?;	

ImageReference : 'img' imgfile=IMGREF;

IMGREF : (ID '/')* ID '.' ID; 

// Expressions

AExpression returns aadl2::PropertyExpression: AOrExpression;

AOrExpression returns aadl2::PropertyExpression:
	AAndExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AAndExpression)*;

OpOr:
	'||';

AAndExpression returns aadl2::PropertyExpression:
	AEqualityExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=AEqualityExpression)*;

OpAnd:
	'&&';

AEqualityExpression returns aadl2::PropertyExpression:
	ARelationalExpression (=>({ABinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=ARelationalExpression)*;

OpEquality:
	'==' | '!=' | '===' | '!==';

ARelationalExpression returns aadl2::PropertyExpression:
	AOtherOperatorExpression
	( =>({ABinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AOtherOperatorExpression)*;

OpCompare:
	'>=' | '<' '=' | '>' | '<' ;

AOtherOperatorExpression returns aadl2::PropertyExpression:
	AAdditiveExpression (=>({ABinaryOperation.leftOperand=current} feature=OpOther)
	rightOperand=AAdditiveExpression)*;

OpOther:
	  '->' 
	| '..<'
	| '>' '..'
	| '..'
	| '=>' 
	| '>' (=>('>' '>') | '>') 
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:';

AAdditiveExpression returns aadl2::PropertyExpression:
	AMultiplicativeExpression (=>({ABinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=AMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

AMultiplicativeExpression returns aadl2::PropertyExpression:
	AUnaryOperation (=>({ABinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=AUnaryOperation)*;

OpMulti:
	'*' | '**' | '/' | '%';

AUnaryOperation returns aadl2::PropertyExpression:
	{AUnaryOperation} feature=OpUnary operand=AUnaryOperation | APrimaryExpression;

OpUnary:
	"!" | "-" | "+";
	
APrimaryExpression returns aadl2::PropertyExpression:
	ALiteral | AVariableReference |
	AParenthesizedExpression;

ALiteral returns aadl2::PropertyExpression:
	ASetTerm | AListTerm |
	ABooleanLiteral |
	ARealTerm | AIntegerTerm |  
	ANullLiteral |
	StringTerm 
;

AIntegerTerm returns aadl2::IntegerLiteral:
	value=AInt (unit=[aadl2::UnitLiteral|ID])?
	;

AInt returns aadl2::Integer:
	INTEGER_LIT ;

ARealTerm returns aadl2::RealLiteral:
	value=AReal (unit=[aadl2::UnitLiteral|ID])?
	;

AReal returns aadl2::Real:
	REAL_LIT ;

ANumericRangeTerm returns aadl2::RangeValue:
	minimum=NumAlt //(RealTerm|IntegerTerm| SignedConstant | ConstantValue)  
		'..' maximum=NumAlt//(RealTerm|IntegerTerm| SignedConstant | ConstantValue)
	( 'delta' delta=NumAlt//(RealTerm|IntegerTerm| SignedConstant | ConstantValue)
		
	)?
	;

NumAlt  returns aadl2::PropertyExpression: 
	ARealTerm|AIntegerTerm
;

ASetTerm returns aadl2::PropertyExpression:
//	{ASetLiteral} '#' '{' (elements+=AExpression (',' elements+=AExpression )*)? '}'
	{ASetLiteral}  '{' (elements+=AExpression (',' elements+=AExpression )*)? '}'
;

AListTerm returns aadl2::PropertyExpression:
	{AListTerm} '#' '[' (elements+=AExpression (',' elements+=AExpression )*)? ']'
;


AParenthesizedExpression returns aadl2::PropertyExpression:
	'(' AExpression ')';

ABooleanLiteral returns aadl2::PropertyExpression :
	  {aadl2::BooleanLiteral}(value?='true'|'false');


ANullLiteral returns AExpression :
	{ANullLiteral} 'null';


StringTerm returns aadl2::StringLiteral:
	value=NoQuoteString ;


NoQuoteString :
	// remove quotes from string in ValueConverter
	STRING
;


terminal fragment
EXPONENT  :  ('e'|'E') ('+'|'-')? ( DIGIT )+  ;

terminal fragment
INT_EXPONENT :  ('e'|'E') ('+')? ( DIGIT )+ ;


terminal REAL_LIT : 	
	(DIGIT)+('_' (DIGIT)+)* ( '.' (DIGIT)+('_' (DIGIT)+)* ( EXPONENT )?)
  ;

terminal INTEGER_LIT : 
		(DIGIT)+('_' (DIGIT)+)*
		(( '#' BASED_INTEGER  '#' ( INT_EXPONENT )? )
			| (INT_EXPONENT)?
		)
  ;

terminal fragment
DIGIT     :  ( '0'..'9' ) ;

terminal fragment
EXTENDED_DIGIT     :  ( '0'..'9' | 'a'..'f' | 'A'..'F') ;

terminal fragment
BASED_INTEGER      :  ( EXTENDED_DIGIT ) ( ('_')? EXTENDED_DIGIT )* ;


// Qualified classifier reference
AadlClassifierReference:
	ID ('::' ID)+ ('.' ID)?;

AADLPROPERTYREFERENCE: ID ('::' ID)?;


URIID: STRING;

QualifiedName: ID ('.' ID)*;

Number hidden():
HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

terminal HEX:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+ 
	('#' (('b'|'B')('i'|'I') | ('l'|'L')))?;
	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9'|'_')*; 	
terminal DECIMAL:
	INT 
	(('e'|'E') ('+'|'-')? INT)? 
	(('b'|'B')('i'|'I'|'d'|'D') | ('l'|'L'|'d'|'D'|'f'|'F'))?;
	
