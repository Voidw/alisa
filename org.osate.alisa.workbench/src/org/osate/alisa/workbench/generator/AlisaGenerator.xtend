/*
 * generated by Xtext
 */
package org.osate.alisa.workbench.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.osate.aadl2.instance.ComponentInstance
import org.osate.alisa.workbench.alisa.AlisaWorkArea
import org.osate.alisa.workbench.alisa.AssuranceCasePlan
import org.osate.alisa.workbench.util.AlisaWorkbenchUtilsExtension
import org.osate.reqspec.reqSpec.Hazard
import org.osate.verify.verify.AllExpr
import org.osate.verify.verify.AndThenExpr
import org.osate.verify.verify.ArgumentExpr
import org.osate.verify.verify.Claim
import org.osate.verify.verify.ConditionExpr
import org.osate.verify.verify.ConditionalExpr
import org.osate.verify.verify.FailThenExpr
import org.osate.verify.verify.RefExpr
import org.osate.verify.verify.VerificationAssumption
import org.osate.verify.verify.VerificationCondition
import org.osate.verify.verify.VerificationPrecondition

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.osate.aadl2.instantiation.InstantiateModel.buildInstanceModelFile

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class AlisaGenerator implements IGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val workarea = resource.contents.get(0) as AlisaWorkArea
		workarea.cases.forEach [ mycase |
			fsa.generateFile('''«mycase.name».assure''', generateCase(mycase))
		]
	}

	
	@Inject extension IQualifiedNameProvider qualifiedNameProvider

	extension AlisaWorkbenchUtilsExtension awue = new AlisaWorkbenchUtilsExtension

	def generateCase(AssuranceCasePlan acp) {
		val si = acp.system.buildInstanceModelFile
		si.generate(acp)
	}

	def CharSequence generate(ComponentInstance ci, AssuranceCasePlan acp) {
		val myplans = ci.getVerificationPlans(acp);
		'''	
		«IF !myplans.empty»
		case «acp.name» for «ci.componentClassifier.getQualifiedName»
		uri "«ci.URI.toString»"
		[
			success 0
			fail 0
			unknown 0
			tbd 0
			weight 1
			«FOR myplan : myplans»
			«FOR claim : myplan.claim»
			«claim.generate»
			«ENDFOR»
			«ENDFOR»
			«FOR subci : ci.componentInstances»
			«subci.generate(acp)»
			«ENDFOR»
		]
		«ENDIF»
		'''
	}

	def CharSequence generate(Claim claim) {
		'''
		claim «claim.name» for «claim?.requirement.fullyQualifiedName»
		[
			success  0
			fail 0
			unknown 0
			tbd 0
			weight 1
		    «FOR subclaim : claim?.subclaim»
			«subclaim.generate»
		    «ENDFOR»
		    «claim.assert.generate»
		]
		'''
	}

	def CharSequence generate(ArgumentExpr expr) {
		switch expr {
			AllExpr: expr.doGenerate
			AndThenExpr: expr.doGenerate
			FailThenExpr: expr.doGenerate
			ConditionalExpr: expr.doGenerate
			RefExpr: expr.doGenerate
		}
	}

	def doGenerate(AllExpr expr) {
		'''«FOR subexpr : expr.all»
		«subexpr.generate»
		«ENDFOR»
		'''
	}

	def doGenerate(AndThenExpr expr) {
		'''
		if
			«expr.left.generate»
		then
			«expr.right.generate»
		'''
	}

	def doGenerate(FailThenExpr expr) {
		'''
		fail 
			«expr.left.generate»
		then
			«expr.right.generate»
		'''
	}

	def doGenerate(ConditionalExpr expr) {
		'''
		«IF expr.condition.evaluate»
		«expr.generate»
		«ENDIF»
		'''
	}

	def doGenerate(RefExpr expr) {
		'''
		verification «expr.verification.name» for «expr.verification.fullyQualifiedName»
		[
			executionstate todo
			resultstate tbd
			weight «expr.theWeight»
		«FOR vacond : expr.verification?.method?.conditions»
			«vacond.generate»
		«ENDFOR»
		]
		'''
	}

	def generate(Hazard ha) {
		'''
			hazard «ha.name» for «ha.fullyQualifiedName»
			[
				sucess  0
				fail 0
				neutral 0
				unknown 0
				weight 1
			]
		'''
	}

	def generate(VerificationCondition vc) {
		'''
			«vc.keyword» «vc.name» for «vc.fullyQualifiedName»
			[
				sucess  0
				fail 0
				neutral 0
				unknown 0
				weight 1
			]
		'''
	}

	def evaluate(ConditionExpr expr) {
		true
	}

	def keyword(VerificationCondition vc) {
		switch vc {
			VerificationAssumption: '''assumption'''
			VerificationPrecondition: '''precondition'''
		}
	}

	def getTheWeight(RefExpr expr) {
		switch expr {
			case expr.weight == 0: 1
			default: expr.weight
		}
	}

}
