/*
 * generated by Xtext
 */
package org.osate.alisa.workbench.generator

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.osate.aadl2.instance.ComponentInstance
import org.osate.alisa.workbench.alisa.AlisaWorkArea
import org.osate.alisa.workbench.alisa.AssurancePlan
import org.osate.assure.assure.AssureFactory
import org.osate.assure.assure.ClaimResult
import org.osate.assure.assure.VerificationExecutionState
import org.osate.assure.assure.VerificationExpr
import org.osate.assure.assure.VerificationResultState
import org.osate.categories.categories.SelectionCategory
import org.osate.verify.verify.AllExpr
import org.osate.verify.verify.AndThenExpr
import org.osate.verify.verify.ArgumentExpr
import org.osate.verify.verify.Claim
import org.osate.verify.verify.FailThenExpr
import org.osate.verify.verify.RefExpr
import org.osate.verify.verify.VerificationCondition
import org.osate.verify.verify.VerificationPrecondition
import org.osate.verify.verify.VerificationValidation
import org.osate.verify.verify.WhenExpr

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.osate.aadl2.instantiation.InstantiateModel.buildInstanceModelFile
import static extension org.osate.alisa.workbench.util.AlisaWorkbenchUtilsExtension.*
import org.osate.assure.assure.AssuranceEvidence
import org.osate.alisa.workbench.alisa.AssuranceTask
import org.osate.categories.categories.RequirementCategory
import org.osate.categories.categories.VerificationCategory
import org.osate.verify.verify.VerificationActivity

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class AlisaGenerator implements IGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val workarea = resource.contents.get(0) as AlisaWorkArea
		workarea.cases.forEach [ mycase |
			switch (mycase){
			AssurancePlan: fsa.generateFile('''«mycase.name».assure''', generateCase(mycase))
			AssuranceTask: fsa.generateFile('''«mycase.name».assure''', generateAssuranceTask(mycase))
			}
		]
	}

	@Inject extension IQualifiedNameProvider qualifiedNameProvider

	val factory = AssureFactory.eINSTANCE
	
	var EList<SelectionCategory> selectionFilter = null
	var EList<RequirementCategory> requirementFilter = null
	var EList<VerificationCategory> verificationFilter = null
	
	def constructAssuranceTask(AssuranceTask at){
		selectionFilter = at.selectionFilter
		requirementFilter = at.requirementFilter
		verificationFilter = at.verificationFilter
		at.assurancePlan?.constructCase
	}
	def generateAssuranceTask(AssuranceTask at){
		selectionFilter = at.selectionFilter
		requirementFilter = at.requirementFilter
		verificationFilter = at.verificationFilter
		at.assurancePlan?.generateCase
	}

	def constructCase(AssurancePlan acp) {
		val si = acp.system.buildInstanceModelFile
		si.construct(acp)
	}

	def generateCase(AssurancePlan acp) {
		val si = acp.system.buildInstanceModelFile
		si.generate(acp)
	}

	def AssuranceEvidence construct(ComponentInstance ci, AssurancePlan acp) {
		val myplans = ci.getVerificationPlans(acp);
		var AssuranceEvidence acase = null
		if (!myplans.empty) {
			acase = factory.createAssuranceEvidence
			acase.name = acp.name
			acase.target = ci.componentClassifier
			acase.instance = ci
			for (myplan : myplans) {
				for (claim : myplan.claim) {
					if (claim.evaluateRequirementFilter)
						acase.claimResult += claim.construct(ci)
				}
			}
			for (subci : ci.componentInstances) {
				acase.subAssuranceEvidence += subci.construct(acp)
			}
		}
		acase
	}

	def CharSequence generate(ComponentInstance ci, AssurancePlan acp) {
		val myplans = ci.getVerificationPlans(acp);
		'''	
			«IF !myplans.empty»
				evidence «acp.name» for «ci.componentClassifier.getQualifiedName»
				instance "«ci.URI.toString»"
				[
					tbdcount 1
					«FOR myplan : myplans»
						«FOR claim : myplan.claim»
						«IF claim.evaluateRequirementFilter»
							«claim.generate(ci)»
						«ENDIF»
						«ENDFOR»
					«ENDFOR»
					«FOR subci : ci.componentInstances»
						«subci.generate(acp)»
					«ENDFOR»
				]
			«ENDIF»
		'''
	}

	def ClaimResult construct(Claim claim, ComponentInstance ci) { 
		val claimresult = factory.createClaimResult
//		claimresult.name = claim.requirement.name
		claimresult.target = claim.requirement
		if (claim.requirement.target != null) {
			claimresult.instance = claim.requirement.getRequirementTarget(ci)
		}
		for (subclaim : claim?.subclaim) {
			claimresult.subClaimResult += subclaim.construct(ci)
		}
		claimresult.verificationActivityResult.construct(claim.assert)
		claimresult
	}

	def CharSequence generate(Claim claim, ComponentInstance ci) {
		'''
«««			claim «claim.requirement.name» for «claim.requirement.fullyQualifiedName» // TODO remove for, but also remove it in assure
			claim «claim.requirement.fullyQualifiedName»
			«IF claim.requirement.target != null»
				instance "«claim.requirement.getRequirementTarget(ci)»"
			«ENDIF»
			[
				tbdcount 1
			    «FOR subclaim : claim?.subclaim»
				«subclaim.generate(ci)»
				«ENDFOR»
				«claim.assert.generate»
				]
			'''
	}

	def void construct(List<VerificationExpr> arl, ArgumentExpr expr) {
		switch expr {
			AllExpr: arl.doConstruct(expr)
			AndThenExpr: arl.doConstruct(expr)
			FailThenExpr: arl.doConstruct(expr)
			WhenExpr: arl.doConstruct(expr)
			RefExpr: if(expr.verification.evaluateVerificationFilter) arl.doConstruct(expr)
		}
	}

	def CharSequence generate(ArgumentExpr expr) {
		switch expr {
			AllExpr: expr.doGenerate
			AndThenExpr: expr.doGenerate
			FailThenExpr: expr.doGenerate
			WhenExpr: expr.doGenerate
			RefExpr: if(expr.verification.evaluateVerificationFilter) expr.doGenerate
		}
	}

	def void doConstruct(List<VerificationExpr> arl, AllExpr expr) {
		for (subexpr : expr.all) {
			arl.construct(subexpr)
		}
	}

	def doGenerate(AllExpr expr) {
		'''
			«FOR subexpr : expr.all»
				«subexpr.generate»
			«ENDFOR»
		'''
	}

	def void doConstruct(List<VerificationExpr> arl, AndThenExpr expr) {
		val andres = factory.createAndThenResult
		andres.first.construct(expr.left)
		andres.second.construct(expr.right)
		arl += andres
	}

	def doGenerate(AndThenExpr expr) {
		'''
			andthen
				«expr.left.generate»
			do
				«expr.right.generate»
			[
				tbdcount 1
			]
		'''
	}

	def void doConstruct(List<VerificationExpr> arl, FailThenExpr expr) {
		val failthenres = factory.createFailThenResult
		failthenres.first.construct(expr.left)
		failthenres.second.construct(expr.right)
		arl += failthenres
	}

	def doGenerate(FailThenExpr expr) {
		'''
			failthen 
				«expr.left.generate»
			do
				«expr.right.generate»
			[
				«IF expr.unknown»unknownthen«ENDIF»
				«IF expr.failed»failthen«ENDIF»
				tbdcount 1
			]
		'''
	}

	def void doConstruct(List<VerificationExpr> arl, WhenExpr expr) {
		if (expr.evaluateSelectionCondition) {
			arl.construct(expr.verification)
		}
	}

	def doGenerate(WhenExpr expr) {
		'''
			«IF expr.evaluateSelectionCondition»
				«expr.verification.generate»
			«ENDIF»
		'''
	}

	def void doConstruct(List<VerificationExpr> arl, RefExpr expr) {
		val vr = factory.createVerificationActivityResult
		vr.resultState = VerificationResultState.TBD
		vr.executionState = VerificationExecutionState.TODO
		val conds = expr.verification?.method?.conditions
		if (conds != null) {
			for (vacond : conds) {
				arl.doConstruct(vacond)
			}
		}
	}

	def doGenerate(RefExpr expr) {
		'''
«««			verification «expr.verification.name» for «expr.verification.fullyQualifiedName»
			verification «expr.verification.fullyQualifiedName»
			[
				executionstate todo
				resultstate tbd
				tbdcount 1
				«FOR vacond : expr.verification?.method?.conditions ?: #{}»
					«vacond.generate»
				«ENDFOR»
			]
		'''
	}

	def void doConstruct(List<VerificationExpr> arl, VerificationCondition vc) {
		switch (vc) {
			VerificationValidation: {
				val vcr = factory.createValidationResult
			}
			VerificationPrecondition: {
				val vcr = factory.createPreconditionResult
			}
		}
	}

	def generate(VerificationCondition vc) {
		'''
«««			«vc.keyword» «vc.name» for «vc.fullyQualifiedName»
			«vc.keyword» «vc.fullyQualifiedName»
			[
				executionstate todo
				resultstate tbd
				tbdcount 1
			]
		'''
	}

	def evaluateSelectionCondition(WhenExpr expr) {
		val selection = expr.condition
		if (selectionFilter == null || selectionFilter.empty || selection.empty) return true
		val intersect = selection.copyAll
		intersect.retainAll(selectionFilter) 
		!intersect.isEmpty
	}

	def evaluateRequirementFilter(Claim claim) {
		val req = claim.requirement.category
		if (requirementFilter == null || requirementFilter.empty || req.empty) return true
		val intersect = req.copyAll
		intersect.retainAll(requirementFilter) 
		!intersect.isEmpty
	}

	def evaluateVerificationFilter(VerificationActivity va) {
		val vcs = va.method.category
		if (verificationFilter == null || verificationFilter.empty || vcs.empty) return true
		val intersect = vcs.copyAll
		intersect.retainAll(requirementFilter) 
		!intersect.isEmpty
	}

	def keyword(VerificationCondition vc) {
		switch vc {
			VerificationValidation: '''validation'''
			VerificationPrecondition: '''precondition'''
		}
	}

}
